package httpServer;

import com.maxeler.maxblox.statemachine.SMUtils;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.LMemCommandStream;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.managers.DFEManager;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmAssignableValue;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateValue;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmValue;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushInput;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushOutput;
import com.maxeler.maxcompiler.v2.statemachine.manager.ManagerStateMachine;
import com.maxeler.maxcompiler.v2.statemachine.stdlib._State;

public class LMEM extends ManagerStateMachine {

	public static final String INPUT_MEM_DATA = "dataFromMem";
	public static final String OUTPUT_MEM_COMMAND = "memCmd";
	private final DFEStructType cmdType;
	private final DFEsmPushInput dataFromMem = io.pushInput(INPUT_MEM_DATA, dfeUInt(64), 1);
	private final DFEsmPushInput socketNumberInput = io.pushInput("socketNumberInput", dfeUInt(16), 1);
	private final DFEsmPushInput dataFromCrcIndex = io.pushInput("dataFromCrcIndex", dfeUInt(64), 1);
	private final DFEsmPushOutput fromStateMachineByteNumber = io.pushOutput("fromStateMachineByteNumber", dfeUInt(128), 5);
	private final DFEsmPushOutput outputLmemData = io.pushOutput("outputLmemData", dfeUInt(77), 1);
	private final DFEsmPushOutput memCmdOutput;
	private final DFEsmStateValue memCmdReg;
	private final DFEsmStateValue memCmdRegValid;

	private final int readStreamID;

	private final DFEsmStateValue counter = state.value(dfeUInt(20), 0); // 40
	private final DFEsmStateValue sMemoryRead = state.value(dfeBool(), false);
	private final DFEsmStateValue sMemCmdOutputStall = state.value(dfeBool(), false);
	private final DFEsmStateValue sStartROMAddress = state.value(dfeUInt(19), 0);
	private final DFEsmStateValue sDataBurstLength = state.value(dfeUInt(19), 0);
	private final DFEsmStateValue sFileLengthBytes = state.value(dfeUInt(26), 0);
	private final DFEsmStateValue sSocketNumber = state.value(dfeUInt(16), 0);

	private final DFEsmStateValue sLMemBurstCounter = state.value(dfeUInt(19), 0);
	private final DFEsmStateValue sBurstCounter = state.value(dfeUInt(19), 0);
	private final DFEsmStateValue sLMemBytesSent = state.value(dfeUInt(32), 0);
	private final DFEsmStateValue sFileLengthBytesCounter = state.value(dfeUInt(26), 8);
	private final DFEsmStateValue sAllBytesSentFlag = state.value(dfeBool(), false);
	private final DFEsmStateValue sFileLengthBytesCounterMini = state.value(dfeUInt(8), 8);
	private final DFEsmStateValue sCloseSocketCycleCounter = state.value(dfeUInt(5), 1);
	private final DFEsmStateValue sByteNumberFlag = state.value(dfeBool(), false);
	private final DFEsmStateValue sCloseSocketCycleFlag = state.value(dfeBool(), false);

	public LMEM(DFEManager owner, int readStreamID) {
		super(owner);

		cmdType = LMemCommandStream.getLMemCommandDFEStructType();

		this.readStreamID = readStreamID;

		memCmdReg = _State.value(state, dfeUInt(cmdType.getTotalBits()), "memCmdReg");
		memCmdRegValid = _State.value(state, dfeBool(), false, "memCmdRegValid");
		memCmdOutput = io.pushOutput(OUTPUT_MEM_COMMAND, dfeUInt(cmdType.getTotalBits()), 1);
	}

	@Override
protected void nextState() {

	counter.next <== counter + 1;

	memCmdRegValid.next <== false;
	sMemCmdOutputStall.next <== memCmdOutput.stall;

	IF(dataFromCrcIndex.valid)
	{
		debug.simPrintf("LMEM: Value dataFromCrcIndex=%x\n", dataFromCrcIndex);

		DFEsmAssignableValue startAddressBurst=assignable.value(dfeUInt(19)); //startAddressBurst in LMem
		DFEsmAssignableValue fileLengthBursts=assignable.value(dfeUInt(19)); //length of a file as number of Bursts
		DFEsmAssignableValue fileLengthBytes=assignable.value(dfeUInt(26));  // 2^26 / 1024 /1024 = 64 MB, this is not integer number of bursts, last burst will not be fill to the end

		fileLengthBytes<==dataFromCrcIndex.slice(0, 26);
		fileLengthBursts<==dataFromCrcIndex.slice(26, 19);
		startAddressBurst<==dataFromCrcIndex.slice(45, 19);;

		debug.simPrintf("LMEM: startAddressBurst=%u, fileLengthBursts=%u, fileLengthBytes=%u\n",startAddressBurst,fileLengthBursts,fileLengthBytes);


		sStartROMAddress.next<==startAddressBurst;
		sDataBurstLength.next<==fileLengthBursts;
		sFileLengthBytes.next<==fileLengthBytes;

		sMemoryRead.next <== true;
	}

	IF((sMemoryRead===true))
	{
		IF((~memCmdOutput.stall))
		{
			sLMemBurstCounter.next<==sLMemBurstCounter+1;
			//debug.simPrintf("LMEM: Tick=%u, executing read command\n",counter);
			makeReadOrWriteCommand(memCmdReg, //reference to an object,adresa=base + x, streamID
					//constant.value(dfeUInt(32), 0), //basAddressBursts+ memWriteCommitPointer.cast(dfeUInt(32)
					(sStartROMAddress+sLMemBurstCounter).cast(dfeUInt(32)), //adresaRom ie. burst number
					readStreamID); //readStreamID

			memCmdRegValid.next <== true;

			IF(sLMemBurstCounter.eq(sDataBurstLength-1))
			{
				sMemoryRead.next<==false;
//				sRomAddressValid.next<==false;
//				sCurrentState.next<==States.start; //after memory was read, change current state;
//				sCurrentROMAddress.next<==0;
//				sRomDataOutValid.next<==0;

				sLMemBurstCounter.next<==0;
				debug.simPrintf("LMEM: Last LMEM read command sent, sLMemBurstCounter=%u\n", sLMemBurstCounter);
			}
		}
	}

	IF(dataFromMem.valid)
	{
		sLMemBytesSent.next<==sLMemBytesSent+8;
		sFileLengthBytesCounter.next<==sFileLengthBytesCounter+8;
		sFileLengthBytesCounterMini.next<==sFileLengthBytesCounterMini+8;

		//debug.simPrintf("Tick=%u, sLMemBurstCounter=%u, LMem dataFromLMem.valid=%x, dataFromLMem=%x,\n",counter,sLMemBurstCounter,dataFromMem.valid, dataFromMem)

		IF(sFileLengthBytesCounter>=sFileLengthBytes)
		{
			sAllBytesSentFlag.next<==true;
		}

		IF(~sByteNumberFlag)
		{
			sCloseSocketCycleFlag.next<==true;
			sByteNumberFlag.next<==true;
		}

		IF(sFileLengthBytesCounterMini===192) //LMEM data burst size
		{
			sBurstCounter.next<==sBurstCounter+1;
			sFileLengthBytesCounterMini.next<==8;

			debug.simPrintf("LMEM: tick=%u, sBurstCounter=%u\n",counter,sBurstCounter);
		}
	}

	IF(sBurstCounter===sDataBurstLength)
	{
		sLMemBytesSent.next<==0;
		sAllBytesSentFlag.next<==false;
		sFileLengthBytesCounter.next<==8;
		sBurstCounter.next<==0;
		sDataBurstLength.next<==1;
		sByteNumberFlag.next<==false;

		debug.simPrintf("LMEM: Tick=%u, sBurstCounter===sDataBurstLength\n",counter);
	}

	IF(sCloseSocketCycleFlag)
	{
		sCloseSocketCycleFlag.next<==false;
	}

	IF(~outputLmemData.stall) //output.stall
	{
//		IF((sMemoryRead===true)) //i crc je bio valid i stanje je bilo endGetRequest
		//{
//			sCurrentROMAddress.next<==sCurrentROMAddress+1;
//			sRomDataOutValid.next<==true;
		//};
	}

	IF(socketNumberInput.valid)
	{
		sSocketNumber.next <== socketNumberInput;
		debug.simPrintf("LMEM: tick=%u, socket number from the StateMachine received, sSocketNumber=%u\n", counter, socketNumberInput);
	}
}

	@Override
protected void outputFunction() {

		outputLmemData.valid <== false;
		outputLmemData <== 0;
		dataFromMem.stall <== outputLmemData.stall;
		socketNumberInput.stall <== outputLmemData.stall;
		dataFromCrcIndex.stall <== outputLmemData.stall;

		IF(dataFromMem.valid & ~sAllBytesSentFlag)
		{
			//default
			DFEsmValue data,mod,eof,sof, socket;
			data = dataFromMem;
			mod = constant.value(dfeUInt(3),0);
			eof = constant.value(dfeBool(),1);
			sof = constant.value(dfeBool(),1);

			socket = constant.value(dfeUInt(8),0);//sSocketNumber.cast(dfeUInt(8)); //input.slice(64, 8).cast(dfeUInt(8)); // bajt 11

			outputLmemData.valid <== dataFromMem.valid;
			outputLmemData<== sof # eof # mod # socket # data;

			IF(sFileLengthBytesCounter>=sFileLengthBytes)
			{
				outputLmemData.valid <== dataFromMem.valid;

				data = dataFromMem;

				DFEsmAssignableValue difference = assignable.value(dfeUInt(26));
				difference <== 8 - (sFileLengthBytesCounter-sFileLengthBytes);
				IF(difference===8) difference <== 0;

				mod = difference.cast(dfeUInt(3));
				eof = constant.value(dfeBool(),1);
				sof = constant.value(dfeBool(),1);

				debug.simPrintf("LMEM: tick=%u, sending: mod=%u, sFileLengthBytesCounter=%u, sFileLengthBytes=%u\n", counter, mod, sFileLengthBytesCounter, sFileLengthBytes);

				outputLmemData<== sof # eof # mod # socket # data;

			}
		}

		fromStateMachineByteNumber.valid<==false;
		fromStateMachineByteNumber<==0;

		IF(sCloseSocketCycleFlag)
		{
			fromStateMachineByteNumber.valid<==true;
			fromStateMachineByteNumber<==sFileLengthBytes.cast(dfeUInt(128));

			debug.simPrintf("LMEM: sFileLengthBytes=%x\n", sFileLengthBytes);
		}

		memCmdOutput<==0;
		memCmdOutput.valid<==false;

		IF(~sMemCmdOutputStall) //
		{
			//commands for the memory controller
			memCmdOutput <== memCmdReg;
			memCmdOutput.valid <== memCmdRegValid;

			IF (memCmdRegValid)
			{
				debug.simPrintf("LMEM: tick=%u, memCmdOutput.stall=%u, Pushing out memory command***: %x\n", counter, memCmdOutput.stall, memCmdReg);
			}
		}

		IF(dataFromMem.valid)
		{
		  //debug.simPrintf("LMEM: Tick=%u, output=%x, output.valid=%u, dataFromMem=%x, sFileLengthBytesCounter=%u, sFileLengthBytes=%u\n", counter, outputLmemData,outputLmemData.valid, dataFromMem, sFileLengthBytesCounter, sFileLengthBytes);
		}
}

	private void makeReadOrWriteCommand(DFEsmStateValue cmdReg, DFEsmValue address, int streamIx) {
		SMUtils.assignField(cmdReg.next, cmdType, "address", address);
		SMUtils.assignField(cmdReg.next, cmdType, "size", 1);
		SMUtils.assignField(cmdReg.next, cmdType, "inc", 1);
		SMUtils.assignField(cmdReg.next, cmdType, "tag", 0);
		SMUtils.assignField(cmdReg.next, cmdType, "stream", 1 << streamIx);
	}
}
