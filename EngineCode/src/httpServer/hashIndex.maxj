package httpServer;

import com.maxeler.maxcompiler.v2.managers.DFEManager;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmAssignableValue;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmSinglePortMappedROM;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateValue;
import com.maxeler.maxcompiler.v2.statemachine.Latency;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushInput;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushOutput;
import com.maxeler.maxcompiler.v2.statemachine.manager.ManagerStateMachine;

public class hashIndex extends ManagerStateMachine {
	// BRAM memories
	private final DFEsmSinglePortMappedROM romHashIndex1;
	private final DFEsmSinglePortMappedROM romHashIndex2;

	private final DFEsmStateValue sHashIndexDataOutValid = state.value(dfeBool(), false);
	private final DFEsmStateValue sWhatHashIndexToUse = state.value(dfeUInt(1),	0);
	private final DFEsmPushInput crcResultInput = io.pushInput("crcResultInput", dfeUInt(16), 1);
	private final DFEsmPushOutput hashIndexOutput = io.pushOutput("hashIndexOutput", dfeUInt(64), 1);
	//private final DFEsmPushOutput outputHashIndex = io.pushOutput("outputHashIndex", dfeUInt(128), 1);
	private final DFEsmStateValue counter = state.value(dfeUInt(20), 0); // 40

	public hashIndex(DFEManager owner) {
		super(owner);

		// Hash Index Tables
		romHashIndex1 = mem.romMapped("romHashIndex1", dfeUInt(64), 32768,	Latency.ONE_CYCLE);
		romHashIndex2 = mem.romMapped("romHashIndex2", dfeUInt(64), 32768,	Latency.ONE_CYCLE);
	}

	@Override
	protected void nextState() {

		counter.next<==counter+1;

		IF(crcResultInput.valid)
		{
			romHashIndex1.address <== crcResultInput.slice(0, 15);
			romHashIndex2.address <== crcResultInput.slice(0, 15);
			sWhatHashIndexToUse.next <== crcResultInput[15];

			debug.simPrintf("hashIndex: crcResultInput.valid=%d, crcResultInput(0, 15)=%u, sWhatHashIndexToUse=%u\n", crcResultInput.valid, crcResultInput.slice(0, 15),crcResultInput[15]);

			sHashIndexDataOutValid.next<==true;
		}

		IF(sHashIndexDataOutValid===true) //
		{
			DFEsmAssignableValue hashIndexData = assignable.value(dfeUInt(64));
			hashIndexData <== 0;

			IF(sWhatHashIndexToUse===0)
			{
				hashIndexData <== romHashIndex1.dataOut;
			}
			ELSE
			{
				hashIndexData <== romHashIndex2.dataOut;
			}

			//ternary operatory is not implemented in the StateMachine
			//hashIndexData <== sWhatHashIndexToUse?romHashIndex1.dataOut:romHashIndex2.dataOut;

			debug.simPrintf("hashIndex: Value romHashIndex.dataOut=%x, romHashIndex.dataOut=%x, sUseHashIndex=%x, current=%u\n", romHashIndex1.dataOut, romHashIndex2.dataOut, sWhatHashIndexToUse, counter);

			DFEsmAssignableValue startAddressBurst=assignable.value(dfeUInt(19)); //startAddressBurst in LMem
			DFEsmAssignableValue fileLengthBursts=assignable.value(dfeUInt(19)); //length of a file as number of Bursts
			DFEsmAssignableValue fileLengthBytes=assignable.value(dfeUInt(26));  // 2^26 / 1024 /1024 = 64 MB, ali ovo ipak nije celobrojan broj Burstova, poslednji burst nece biti zauzet do kraja

			fileLengthBytes<==hashIndexData.slice(0, 26); //romHashIndex.dataOut.slice(0, 26); //file length + ResponseHeaderlength(56 bytes)
			fileLengthBursts<==hashIndexData.slice(26, 19); //romHashIndex.dataOut.slice(26, 19);
			startAddressBurst<==hashIndexData.slice(45, 19); //romHashIndex.dataOut.slice(44, 19);

			debug.simPrintf("hashIndex: startAddressBurst=%u, fileLengthBursts=%u, fileLengthBytes=%u\n",startAddressBurst,fileLengthBursts,fileLengthBytes);

			sHashIndexDataOutValid.next<==false;

			//debug.simPrintf("addressByte1=%u, addressByte2=%u, addressByte3=%u, addressByte4=%u\n",addressByte1,addressByte2,addressByte3,addressByte4);
			//debug.simPrintf("VALID romHashIndex, romHashIndex.dataOut=%x, startAddress=%u,addressNumber=%u, current=%u\n", romHashIndex.dataOut,startAddress,addressNumber,counter);
		}
	}

	@Override
	protected void outputFunction() {

			IF(crcResultInput.valid)
			{
				debug.simPrintf("hashIndex: tick=%u, parallelCRC: crcResultInput=0x%x\n", counter, crcResultInput);
			}

			DFEsmAssignableValue hashIndexData = assignable.value(dfeUInt(64));
			hashIndexData <== 0;

			IF(sWhatHashIndexToUse===0)
			{
				hashIndexData <== romHashIndex1.dataOut;
			}
			ELSE
			{
				hashIndexData <== romHashIndex2.dataOut;
			}

			hashIndexOutput.valid <== false;
			hashIndexOutput <==0;

			IF(sHashIndexDataOutValid===true) //
			{
				hashIndexOutput.valid <== true;
				hashIndexOutput <== hashIndexData;
			}
	}
}