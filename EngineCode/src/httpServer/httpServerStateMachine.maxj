package httpServer;

import java.math.BigInteger;

import com.maxeler.maxcompiler.v2.managers.DFEManager;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmAssignableValue;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmMemAddress;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateEnum;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateValue;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmValue;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushInput;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushOutput;
import com.maxeler.maxcompiler.v2.statemachine.manager.ManagerStateMachine;

public class httpServerStateMachine extends ManagerStateMachine {

	enum Modes {
		COUNTING_UP, HOLD_COUNT, COUNTING_DOWN
	}

	enum States {
		start, // 0
		URI, // 1
		HttpVersion, // 2
		Headers, // 3
		CR, LF, BlankLine, endGETrequesta
		// receivingRequestLine, receivingURI,
		// receivingHttpVersion,receivingBlankLine,
	}

	enum StanjeCRLF {
		prijemCR, // 0
		prijemLF, // 1
		// receivingRequestLine, receivingURI,
		// receivingHttpVersion,receivingBlankLine,
	}

	// state
	private final DFEsmStateValue counter = state.value(dfeUInt(20), 0); // 40
	private final DFEsmStateValue sDataPrevious = state.value(dfeUInt(64), 0);
	private final DFEsmStateValue sDataValid = state.value(dfeBool(), 0);
	// private final DFEsmStateValue sRunOneMoreTick = state.value(dfeBool(),false);

	// private final DFEsmStateValue sOuputEmpty = state.value(dfeBool(), true);
	private final DFEsmStateValue sMemoryRead = state.value(dfeBool(), false);
	private final DFEsmStateValue sCurrentROMAddress = state.value(dfeUInt(32),	0);

	private final DFEsmStateValue sPrev2Bytes = state.value(dfeUInt(16), 0);
	private final DFEsmStateValue sPrev2BytesArray[] = new DFEsmStateValue[8];
	private final DFEsmStateValue sOutputStall = state.value(dfeBool(), false);

	private final DFEsmStateValue sStoreURLValid = state.value(dfeBool(),false);
	private final DFEsmStateValue sStoreURL = state.value(dfeUInt(512), 0); // 192
	private final DFEsmStateValue sBitNumber = state.value(dfeUInt(9), 0);

	// State - state varibles
	private final DFEsmStateValue sCounter;
	private final DFEsmStateValue sNumericCurrentState;
	private final DFEsmStateValue sHoldCounter;
	private final DFEsmStateEnum<Modes> sMode;
	private final DFEsmStateEnum<States> sCurrentState;

	// IO
	private final DFEsmPushInput input = io.pushInput("tcp_to_sm", dfeUInt(77),1); // UDP RX stream format: 748 bits


	private final DFEsmPushOutput checksumOutput = io.pushOutput("checksumOutput", dfeUInt(512), 4);

	//
	private final DFEsmValue byte1;
	private final DFEsmValue byte2;
	private final DFEsmValue byte3;
	private final DFEsmValue byte4;
	private final DFEsmValue byte5;
	private final DFEsmValue byte6;
	private final DFEsmValue byte7;
	private final DFEsmValue byte8;

	private final DFEsmStateValue sInputValid = state.value(dfeBool(), false);

	//private final DFEsmStateValue sHashZbirRegister = state.value(dfeUInt(15),0);
	//private final DFEsmStateValue sHashZbirValid = state.value(dfeBool(), false);

	DFEsmMemAddress adresaRom;

	private final DFEsmValue dataBytes[];
	// private final DFEsmValue zbir=constant.value(dfeUInt(8), 0);

	private final DFEsmValue data; //
	private final DFEsmValue mod;
	private final DFEsmValue eof;
	private final DFEsmValue sof;
	// private final DFEsmValue checksum_bad;
	private final DFEsmValue socket;

	public httpServerStateMachine(DFEManager owner) { //int readStreamID
		super(owner);

		// u konstruktoru se sa State varijabla radi sa '='
		// a u nextState() i OutputFunction() sa <== connect operatorom
		// ???????????????????????

		// put code in the contructor,
		// java class fields defined above (dostupna svim metodama unutar klase)

		// TCP rx/tx format: fields extraction
		data = input.slice(0, 64).cast(dfeUInt(64)); // bajt
		socket = input.slice(64, 8).cast(dfeUInt(8)); // bajt 11
		mod = input.slice(72, 3).cast(dfeUInt(3)); // bajt 1
		eof = input.slice(75, 1).cast(dfeUInt(1)); // bajt 1
		sof = input.slice(76, 1).cast(dfeUInt(1)); // bajt 1

		// UDP TX format stream:
		// name offset width(bits)

		// data 0 64
		// mod 64 3
		// eof 67 1
		// sof 68 1
		// socket 69 8
		// ===== 77

		// bits ordering: 77|76|75|...|63|...|4|3|2|1|0

		// State
		sMode = state.enumerated(Modes.class, Modes.COUNTING_UP);
		sCurrentState = state.enumerated(States.class, States.start);
		sCounter = state.value(dfeUInt(32), 0);
		sNumericCurrentState = state.value(dfeUInt(16), 0);
		sHoldCounter = state.value(dfeUInt(16), 0);

		for (int i = 0; i < sPrev2BytesArray.length; i++) {
			sPrev2BytesArray[i] = state.value(dfeUInt(8), 0);
		}

		dataBytes = new DFEsmValue[8];

		dataBytes[0] = data.slice(0, 8).cast(dfeUInt(8)); // #1
		dataBytes[1] = data.slice(8, 8).cast(dfeUInt(8)); // #2
		dataBytes[2] = data.slice(16, 8).cast(dfeUInt(8)); // #3
		dataBytes[3] = data.slice(24, 8).cast(dfeUInt(8)); // #4
		dataBytes[4] = data.slice(32, 8).cast(dfeUInt(8)); // #5
		dataBytes[5] = data.slice(40, 8).cast(dfeUInt(8)); // #6
		dataBytes[6] = data.slice(48, 8).cast(dfeUInt(8)); // #7
		dataBytes[7] = data.slice(56, 8).cast(dfeUInt(8)); // #8

		// extract all 64 bits at once in parallel
		byte1 = data.slice(0, 8).cast(dfeUInt(8)); // #1
		byte2 = data.slice(8, 8).cast(dfeUInt(8)); // #2
		byte3 = data.slice(16, 8).cast(dfeUInt(8)); // #3
		byte4 = data.slice(24, 8).cast(dfeUInt(8)); // #4
		byte5 = data.slice(32, 8).cast(dfeUInt(8)); // #5
		byte6 = data.slice(40, 8).cast(dfeUInt(8)); // #6
		byte7 = data.slice(48, 8).cast(dfeUInt(8)); // #7
		byte8 = data.slice(56, 8).cast(dfeUInt(8)); // #8

		// int r=7/0;;

		// ramMemorija.write(constant.var(0).cast(dfeUInt(10)),
		// constant.var(124).cast(dfeUInt(64)) , constant.var(true));
		// DFEVar outputData =
		// ramMemorija.read(constant.var(0).cast(dfeUInt(10)));
		//
		// //Java kod se izvrsi, pa se onda onda builduje .max file koji se
		// "spusta" na hardver
		// String text = "This text came from a FPGA";
		// int DATA_SIZE=text.length();
		// //byte niz[] = new byte[L]; //definise se niz duzine 1024 elementa
		// kod koga su elementi 1 bajt = 8 bita
		// Bits niz[] = new Bits[DATA_SIZE];
		//
		// //IF(data1===constant.var(dfeUInt(3),0)) //if ne radi u KERNEL-ima,
		// samo u State Machine-i
		//
		//
		// for(int i=0;i<DATA_SIZE;i++)
		// {
		// niz[i]=new Bits(8,text.charAt(i)); //inicijalizacija ROM memorije sa
		// inicijalnim vrednostima u vidu MaxJ Bits objekata
		// }
		// //Memory<DFEVar> romMemorija = mem.alloc(dfeUInt(8), DATA_SIZE);
		// //romMemorija.setContents(niz);
		//
		// int BrojBitaZaAdresiranje = MathUtils.bitsToAddress(DATA_SIZE);
		// System.out.println("Potreban broj bita za adresiranje " + DATA_SIZE +
		// " memorijskih lokacija je: " + BrojBitaZaAdresiranje);
		// //int y=7/0;

	}

	@Override
	protected void nextState() { //executes in next tick?

//		IF(sCloseSocketCycleFlag)
//		{
//			sCloseSocketCycleCounter.next<==sCloseSocketCycleCounter+1;
//			IF(sCloseSocketCycleCounter===16)
//			{
//				sCloseSocketCycleFlag.next<==false;
//				sCloseSocketCycleCounter.next<==1;
//			}
//		}

		IF(sStoreURLValid===true)
		{
			sStoreURLValid.next <== false;
		}

//sOutputStall.next<==output.stall;
		//IF(output.stall===true) sOutputStall.next<==true;

//IF(~output.stall) //output.stall
		IF(sStoreURLValid===sStoreURLValid)
		{

//			DFEsmAssignableValue hashZbir = assignable.value(dfeUInt(15));
//			IF(sHashZbirValid===true)
//			{
//				hashZbir<==sHashZbirRegister;
//				sHashZbirValid.next<==false;
//				debug.simPrintf("Vrednost sHashZbirRegistra=%u\n", sHashZbirRegister);
//			}
//			ELSE
//			{
//				hashZbir<==0;
//			}

			sInputValid.next <== input.valid;

	     	//value assignments
			counter.next <== counter + 1;
			sDataPrevious.next <== data;
			sDataValid.next <== input.valid;

			//sPrev2BytesPoslednja.next <== byte8 # byte7; //2 bytes from the previous cycle
			sPrev2Bytes.next <== byte8 # byte7;

			for(int i=0;i<sPrev2BytesArray.length;i++)
			{
				sPrev2BytesArray[i].next<==dataBytes[i];
			}

			//u ciklusu kada je stanje endGETrequest, znaci da je ulazni request prepoznan
			//to znaci da se odgovor moze poslati klijentu
			//zato u osmatranom trenutku podesi kontrolni signal
			//tako da se vec od sledeceg trenutka pocne sa iscitavanjem podataka
			//iz memorije i slanje ka klijentu
			IF(sCurrentState===States.endGETrequesta)
			{
				sMemoryRead.next <==true; //od sledeceg trenutka ovaj kontrolni signal (inace varijabla stanja) ce imati vrednost true
				sCurrentState.next<==States.start;
			}

			//DFEsmMemAddress adresaRom = romMemorija.address;

			counter.next<==counter+1;

			//		IF(sEndOfReading)
			//		{
			//			sCurrentState.next<==States.start;
			//		}

			//IF((sCurrentROMAddress))

			//case structures
			//IF(input.valid)
			//debug.simPrintf("Tick: %u, sRunOneMoreTick=%u, eof=%x **********\n", counter,sRunOneMoreTick,input.slice(67, 1).cast(dfeUInt(1)));
			//IF(counter>110000) counter.next<==0;

			//IF(input.valid) sRunOneMoreTick.next<==constant.value(dfeBool(),tr);

			//IF(input.valid) counter.next<==0;

			//HTTP request: opsti oblik
			// 1) request-line
			// 2) headers (0 or more)
			// 3) <blank line>
			// 4) body (only for a POST method)

			// URI requests:
			// / -> index.html
			// index.html -> index.html

			int width=32;
			//DFEsmValue headerMethod = smInput.slice(0, width).cast(dfeUInt(width)); // 1|2|3|4|5|6|7|8 => 8|7|6|5|4|3|2|1 posle slice funkcije
			// zasto menja raspored BAJTOVA (ne bitova)?

			//DFEVectorType<DFEsmValue> vector = new DFEVectorType<DFEsmValue>(dfeUInt(8), 8);
			//DFEVector<DFEVar> dataBytes = vector.newInstance(this);

			DFEsmValue methodGET = constant.value(dfeUInt(width),new BigInteger(1,"GET ".getBytes()));

			IF(input.valid)
			{
				//IF(sRunOneMoreTick===true) sRunOneMoreTick.next<==false;
				SWITCH(sCurrentState)
				{
					CASE(States.start)
					{
						//for(int i=0;i<8;i++) //loop unrolling, petlja se pretvara u 8 blokova koji se paralelno izvrsavaju

						//debug.simPrintf("INDEX: startIndex=%u, startIndexFound=%u, endIndex=%u, endIndexFound=%u\n", startIndex,startIndexFound,endIndex,endIndexFound);

						//if zbir>=2, krenuti sa pretragom od prvog indexa space
						//kad detektujem prvi space, to znaci da sledeci bajt nakon njega pocinje startURI
						//sve dok ne detektujem drugi uzastopni space, URI je validan
						//kada se detektuje space to znaci da je bajt iza njega krajURI

						//debug.simPrintf("prijemRequestMethod: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						//DFEsmValue N4bajta = byte1 # byte2 # byte3 # byte4;
						DFEsmValue N4bajta = byte1 # byte2 # byte3 # byte4;
						DFEsmAssignableValue zbir = assignable.value(dfeUInt(4));
						zbir <== 0;

						IF (N4bajta === methodGET) { //condition to move to a next state

							IF(byte4===' ') //space IF sa promenljivima ne RADI kako treba, prolazi cak i kad nije ispunjen uslov
							{
								//sURIMemoryWrite.next<==true;
								//kada se postavi na TRUE, drzi vrednost samo jedan ciklus???? resetuje se posle svakog ciklusa na FALSE
								//uriMemorija.writeEnable<==true; //primljen PRVI space, oznacava da pocinje URI
								//uriMemorija.dataIn<==data;
								//uriMemorija.address<==sUriRamAddress;
								//sUriRamAddress.next<==sUriRamAddress+1;

								DFEsmAssignableValue startIndex=assignable.value(dfeUInt(3));
								startIndex<==7;
								DFEsmAssignableValue endIndex=assignable.value(dfeUInt(3));
								endIndex<==0;

								for(int i=0;i<8;i++)
								{
									IF(dataBytes[i]===' ') //parallel sum
									{
										IF(i<startIndex)
										{
											startIndex<==i;
										}

										IF((i>endIndex)) //(startIndex<endIndex)
										{
											endIndex<==i;
										}

										zbir<==zbir+1;
									}
								}

								IF(zbir>=2)
								{
									//ako je zbir>=2
									//to znaci da je URI poceo i zavrsio se
									//u tekucem ciklusu
									//pronadjen je i startIndex i endIndex
									//moze da se izracuna hash na bajtovima
									//izmedju startIndex i endIndex
									startIndex<==startIndex+1;
									endIndex<==endIndex-1;

									debug.simPrintf("ZBIR>=2, startIndex=%u, endIndex=%u\n",startIndex,endIndex);

								}
								ELSE
								{
									//ako je zbir=0 ili zbir=1,
									//to znaci da je URI (zbir=1) samo zapocet u tekucem ciklusu
									//onda nema potrebe da se vrednost smanjuje za 1
									//startIndex uvecaj za jedan kako bi dobio index bajta
									//od koga pocinje URI
									//kako se URI ne zavrsava u tekucoj word, onda endIndex
									//dodeli vrednost 7m jer jos nije kraj URIja

									//IF(startIndex===7) startIndex<==0;
									//IF(endIndex===0) endIndex<==7;

									startIndex<==startIndex+1;
									endIndex<==7;

								}

								debug.simPrintf("ZBIR zbir=%u, startIndex=%u, endIndex=%u\n",zbir,startIndex,endIndex);

								DFEsmAssignableValue bytes[]=new DFEsmAssignableValue[8];
								for(int u=0;u<8;u++)
								{
									bytes[u]=assignable.value(dfeUInt(8));
									bytes[u]<==dataBytes[u];
									IF(dataBytes[u]===' ')
									{
										bytes[u]<==0;
									}
								}

								for(int t=0;t<8;t++)
								{
									//debug.simPrintf("ZBIR blank[0]=%u, blank[3]=%u, blank[5]=%u, Broj spaceova=%u\n", blank[0],blank[3], blank[5],zbir);
									debug.simPrintf("ZBIR stanje Start bytes[%d]=%u\n",t,bytes[t]);
								}

								debug.simPrintf("Ulaz u doHash funkciju startIndex=%u, endIndex=%u\n",startIndex,endIndex);
								//doHashFunction(hashZbir, bytes,startIndex,endIndex);

								DFEsmAssignableValue startIndexBit = assignable.value(dfeUInt(8));
								DFEsmAssignableValue endIndexBit = assignable.value(dfeUInt(8));
								startIndexBit <== startIndex.cast(dfeUInt(8))*8;
								endIndexBit <== endIndex.cast(dfeUInt(8))*8+7;

								DFEsmAssignableValue bitNumber = assignable.value(dfeUInt(9));
								bitNumber <==0;

								int bitPointer = 0;

								for(int i=0;i<8;i++)
								{
									IF((i>=startIndex) & (i<=endIndex))
									{
											for(int j=0;j<8;j++)
											{
												SWITCH(bitNumber)
												{
													CASE(0) {
														sStoreURL.next[0+j] <== bytes[i].slice(j, 1);
													}

													CASE(8) {
														sStoreURL.next[8+j] <== bytes[i].slice(j, 1);
													}

													CASE(16) {
														sStoreURL.next[16+j] <== bytes[i].slice(j, 1);
													}

													CASE(24) {
														sStoreURL.next[24+j] <== bytes[i].slice(j, 1);
													}

													CASE(32) {
														sStoreURL.next[32+j] <== bytes[i].slice(j, 1);
													}

													CASE(40) {
														sStoreURL.next[40+j] <== bytes[i].slice(j, 1);
													}

													CASE(48) {
														sStoreURL.next[48+j] <== bytes[i].slice(j, 1);
													}

													CASE(56) {
														sStoreURL.next[56+j] <== bytes[i].slice(j, 1);
													}
												}
											}
										bitNumber <== bitNumber + 8;
									}

									bitPointer=bitPointer+8;

									debug.simPrintf("TEST: bitPointer=%u\n", bitPointer);
								}

								debug.simPrintf("TEST: startIndex=%u, endIndex=%u, startIndexBit=%u, endIndexBit=%u, bitNumber=%u, sStoreURL=%x\n", startIndex, endIndex, startIndexBit, endIndexBit, bitNumber, sStoreURL);
								//debug.simPrintf("Racunam hashZbir u stanju Start hashZbir=%u\n", hashZbir);

								sBitNumber.next <== bitNumber;

								//sUriSimpleHash.next<==(byte5+byte6+byte7+byte8).cast(dfeUInt(16));
								//sUriWordCount.next<==sUriWordCount+1; //nakon svakog upisavanja, uvecaj counter RECI za 1
							}

							IF(zbir>=2) //od indexa 4 do index 7, ako je bio
							//IF(byte5===' ' | byte6===' ' | byte7===' ' | byte8===' ') //in current word, also URI was received
							{
								//to znaci da je deo HTTP dela primljen vec u tekucem ciklusu
								//i taj deo treba procesirati tj obraditi i analizirati
								sCurrentState.next<==States.HttpVersion;
								debug.simPrintf("nextState: prijemHttpVersion: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);

								//izracunati hash se moze smatrati validnim pocev od narednog ciklusa
								//sHashZbirFinal.next<==true;
							}
							ELSE {
								//1) postavi da se u sledecem ciklusu predje u URI stanje
								//2) u tekucem ciklusu izracunaj hash
								sCurrentState.next<==States.URI;
								//sHashZbirRegister.next<==hashZbir; //presi hashZbir u sledeci ciklus, jer DFEsmAssignableValue ne moze izmedju ciklusa
								//sHashZbirValid.next<==true;
								//debug.simPrintf("nextState: prijemURI: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
							}
						}
					}
					CASE(States.URI)
					{
						DFEsmAssignableValue sumStateURI = assignable.value(dfeUInt(4));
						sumStateURI <== 0;
						DFEsmAssignableValue startIndex=assignable.value(dfeUInt(3));
						startIndex<==0;
						DFEsmAssignableValue endIndex=assignable.value(dfeUInt(3));
						endIndex<==0;

						debug.simPrintf("TEST: sBitNumber=%u, sStoreURL=%x\n", sBitNumber, sStoreURL);

						for(int i=0;i<8;i++)
						{
							IF(dataBytes[i]===' ')
							{
								IF((i>endIndex))
								{
									endIndex<==i;
								}

								sumStateURI<==sumStateURI+1;
							}
						}

						IF(sumStateURI>=2)
						{
							startIndex<==startIndex+1;
							endIndex<==endIndex-1;

							debug.simPrintf("ZBIR>=2, startIndex=%u, endIndex=%u\n",startIndex,endIndex);

						}
						ELSE IF(sumStateURI===1)
						{
							//IF(startIndex===7) startIndex<==0;
							//IF(endIndex===0) endIndex<==7;

							//startIndex<==startIndex+1;
							IF(endIndex!==0) endIndex<==endIndex-1;
						}
						ELSE IF(sumStateURI===0)
						{
							startIndex<==0;
							endIndex<==7;
						}

						DFEsmAssignableValue bytes[]=new DFEsmAssignableValue[8];
						for(int u=0;u<8;u++)
						{
							bytes[u]=assignable.value(dfeUInt(8));
							bytes[u]<==dataBytes[u];
							IF(dataBytes[u]===' ')
							{
								bytes[u]<==0;
							}
						}

						for(int t=0;t<8;t++)
						{
							//debug.simPrintf("ZBIR blank[0]=%u, blank[3]=%u, blank[5]=%u, Broj spaceova=%u\n", blank[0],blank[3], blank[5],zbir);
							debug.simPrintf("ZBIR stanje URI bytes[%d]=%u\n",t,bytes[t]);
						}

						debug.simPrintf("STANJE URI: Ulaz u doHash funkciju startIndex=%u, endIndex=%u\n",startIndex,endIndex);
						//doHashFunction(hashZbir,bytes,startIndex,endIndex);

						DFEsmAssignableValue bitNumber = assignable.value(dfeUInt(9));
						bitNumber <==sBitNumber;

						int bitPointer = 0;

						for(int i=0;i<8;i++)
						{
							IF((i>=startIndex) & (i<=endIndex))
							{
								for(int t=0;t<504;t++)
								{
									IF(bitNumber===t)
									{
										for(int j=0;j<8;j++)
										{
											sStoreURL.next[t+j] <== bytes[i].slice(j, 1);
											//copyStoreURL.slice(t+j, 1) <== bytes[i].slice(j, 1);
										}

										debug.simPrintf("TEST bytes: bytes=%x\n", bytes[i]);

										//sStoreURL.next[alignRight+j] <== bytes[i].slice(j, 1);
									}
								}

								bitNumber <== bitNumber + 8;
							}

							bitPointer=bitPointer+8;

							debug.simPrintf("TEST: bitPointer=%u\n", bitPointer);
						}

						debug.simPrintf("TEST URL: startIndex=%u, endIndex=%u, bitNumber=%u, sStoreURL=%x\n", startIndex, endIndex, bitNumber, sStoreURL);
						//debug.simPrintf("Racunam hashZbir u stanju Start hashZbir=%u\n", hashZbir);

						sBitNumber.next<==bitNumber;

						//debug.simPrintf("Racunam hashZbir u stanju URI hashZbir=%u\n", hashZbir);

						//ako je sistem u stanju prijema URIja onda, kad detektujes blank predji u stanje prijema Http verzije
						//url koji se prosledjuju requestom: da li je case-sensitive ili ne??? pogledati rfc
						//debug.simPrintf("prijemURI: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						IF (byte1===' ' | byte2===' ' | byte3===' ' | byte4===' ' | byte5===' ' | byte6===' ' | byte7===' ' | byte8===' ')
						{
							//ako je detektovan space => oznacava kraj URI, dalje sleduje HTTP deo
							//dva slucaja:
							// 1) HTTP deo pocinje i zavrsava se u trenutnoj WORD => tada odmah mozes da predjes u stanje koje ide nakon HTTP
							// 2) HTTP deo samo pocinje => tada si od sledece ciklusa u stanju HTTP

							//URI sigurno ne sadrzi blankove (blank se zamenjuje sa %20 ili nekim safe karakterom)
							//pa je blank iza URIja (metoda+blank je ispitano u prijemMetodi
							sCurrentState.next<==States.HttpVersion;
							//sUriRamAddress.next<==0;

							//sHashZbirRegister.next<==hashZbir;
							sStoreURLValid.next<==true; //since end of URI is detected, set valid flag to true value
							//sRomHashIndexAddress.next<==hashZbir;

							//uriMemorija.writeEnable<==true; //ako je stanje URI, onda to znaci da su primljene bar 2 words u razlicitim ciklusima
							//ako je detektovan SPACE (hex 20) onda to znaci da se u ovoj reci zavrsava URI, stigao zavrsni SPACE
							//iskljuci upisivanje u memoriju

							debug.simPrintf("nextState: prijemHttpVersion: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						}
						ELSE{
							//sve dok si u stanju URI, upisuj trenutni podatak u memoriju, povecavaj adresu
							//drugi deo kod definisace prelazak u sledece stanje
							//sUriRamAddress.next<==sUriRamAddress+1;

							sCurrentState.next<==States.URI;
							//sHashZbirRegister.next<==hashZbir; //presi hashZbir u sledeci ciklus, jer DFEsmAssignableValue ne moze izmedju ciklusa
							//sHashZbirValid.next<==true;
						}
					}
					CASE(States.HttpVersion)
					{
						//sCurrentState.next<==States.prijemRequestMethod;

						//debug.simPrintf("prijemHttpVersion: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);

						//kraj HTTP verzije se detektuje sa CRLF sekvencom, tako je prema RFC standardu
						//CR+LF, '\r\n', 0x0D0A (CR=13dec LF=10d)
						//					IF (byte1===13 | byte2===13 | byte3===13 | byte4===13 | byte5===13 | byte6===13 | byte7===13 | byte8===13)
						//					{
						//						//ako je detektovan space ' '
						//						//predji u stanje prijema HTTP
						//						//URI sigurno ne sadrzi blankove (blank se zamenjuje sa %20 ili nekim safe karakterom)
						//						//pa je blank iza URIja (metoda+blank je ispitano u prijemMetodi)
						//						sCurrentState.next<==States.prijemLF;
						//						sHoldCounter.next<==8;
						//
						//						debug.simPrintf("nextState: prijemLF: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						//
						//						//sHoldCounter.next<==3;
						//
						//					}

						//					for(int i=0;i<7;i++) //loop unrolling, petlja se pretvara u 8 blokova koji se paralelno izvrsavaju
						//					{
						//						IF(dataBytes[i]===13 & dataBytes[i+1]===10)
						//						{
						//							sCurrentState.next<==States.BlankLine;
						//							//pronadjen===true;
						//							//debug.simPrintf("nextState: prijemBlankLine: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						//						}
						//					}

						debug.simPrintf("TEST httpState: sBitNumber=%u, sStoreURL=%x\n", sBitNumber, sStoreURL);

						//bezuslovna detekcija dva uzastopna CRLF karaktera
						//1) 2 uzastopna u current WORD
						//2)  uzastopni iz predthodne i tekuce WORD

						//oznacava kraj Requesta, koristiti samo kad se zeli detektovati kraj requesta bez prolaska kroz ostala stanja
						debug.simPrintf("U HTTP stanju: byte1=%x, byte2=%x, sPrev2Bytes=%x\n",byte1,byte2,sPrev2Bytes);
						IF(input.valid)
						{
							//2 bajta iz prethodnog ciklusa da li su jednaka sa pocetnim bajtovima
							IF (byte1===13 & byte2===10)
								IF (sPrev2Bytes === (byte2 # byte1))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 1: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							//0p,1p sa 0,1 - p: prethodno
							//5p,6p,7p sa 0
							//7p sa 0,1,2

							//0p,1p sa 0,1 - p: prethodno
							IF (byte1===13 & byte2===10) //ako su u prethnodnom ciklusu stigla samo dva bajta i to bas CRLF
								IF ((sPrev2BytesArray[1] # sPrev2BytesArray[0]) === (byte2 # byte1))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 7: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							//5p,6p,7p sa 0
							IF ((sPrev2BytesArray[5]===13) & (sPrev2BytesArray[6] === 10))
								IF ((sPrev2BytesArray[7] === 13) & (byte1===10))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 8: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							//7p sa 0,1,2
							IF ((sPrev2BytesArray[7]===13) & (byte1 === 10))
								IF ((byte2 === 13) & (byte3===10))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 9: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							//u trenutnoj word da li su prisutne 2 susedna CRLF
							IF (byte1===13 & byte2===10)
								IF ((byte1 # byte2) === (byte3 # byte4))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 2: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							IF (byte2===13 & byte3===10)
								IF ((byte2 # byte3) === (byte4 # byte5))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 3: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							IF (byte3===13 & byte4===10)
								IF ((byte3 # byte4) === (byte5 # byte6))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 4: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							IF (byte4===13 & byte5===10)
								IF ((byte4 # byte5) === (byte6 # byte7))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 5: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							IF (byte5===13 & byte6===10)
								IF ((byte5 # byte6) === (byte7 # byte8))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 6: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}
						}
					}
					CASE(States.LF) //obrisati prijemCR
					{
						//sCurrentState.next<==States.prijemRequestMethod;
						//debug.simPrintf("prijemLF: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);

						//kraj HTTP verzije se detektuje sa CRLF sekvencom, tako je prema RFC standardu
						//CR+LF, '\r\n', 0x0D0A (CR=13dec LF=10d)
						//IF (byte1===10 | byte2===10 | byte3===10 | byte4===10 | byte5===10 | byte6===10 | byte7===10 | byte8===10)
						{
							//ako je detektovan space ' '
							//predji u stanje prijema HTTP
							//URI sigurno ne sadrzi blankove (blank se zamenjuje sa %20 ili nekim safe karakterom)
							//pa je blank iza URIja (metoda+blank je ispitano u prijemMetodi

							for(int i=0;i<7;i++) //loop unrolling, petlja se pretvara u 8 blokova koji se paralelno izvrsavaju
							{
								IF(dataBytes[i]===13 & dataBytes[i+1]===10)
								{
									//sCurrentState.next<==States.endGETrequesta;
									//debug.simPrintf("nextState: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}
							}

							sCurrentState.next<==States.BlankLine;

							//debug.simPrintf("nextState: prijemBlankLine: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						}
					}
					CASE(States.BlankLine) //blank linija je samo CRLF, jedan do drugog
					{
						//za jednostavan slucaj GET requesta HTTP-a, treba ignorisati sve headere

						//debug.simPrintf("prijemBlankLine: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);

						//				IF (byte1===10 | byte2===10 | byte3===10 | byte4===10 | byte5===10 | byte6===10 | byte7===10 | byte8===10)
						//				{
						//					//ako je detektovan space ' '
						//					//predji u stanje prijema HTTP
						//					//URI sigurno ne sadrzi blankove (blank se zamenjuje sa %20 ili nekim safe karakterom)
						//					//pa je blank iza URIja (metoda+blank je ispitano u prijemMetodi
						//					sCurrentState.next<==States.prijemBlankLine;
						//				}

						for(int i=0;i<7;i++) //loop unrolling, petlja se pretvara u 8 blokova koji se paralelno izvrsavaju
						{
							IF(dataBytes[i]===13 & dataBytes[i+1]===10)
							{
								//sCurrentState.next<==States.endGETrequesta;
								//debug.simPrintf("nextState: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
							}
						}
					}

					CASE(States.endGETrequesta)
					{
						//ako je detektovan kraj HTTP requesta onda mozes da predjes na dohvatanje podataka i vracanja HTTP responsa
						//simple case: vrati odredjenu vrednost promenljive nazad
						//debug.simPrintf("krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
					}
				} //end switch
			}

			SWITCH (sCurrentState) {
				CASE (States.start) {
					//debug.simPrintf("R: prijemStart: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (States.URI) {
					//debug.simPrintf("R: prijemURI: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (States.HttpVersion) {
					//debug.simPrintf("R: prijemHttpVersion: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (States.CR) {
					//debug.simPrintf("R: prijemCR: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (States.LF) {
					//debug.simPrintf("R: prijemLF: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (States.BlankLine) {
					//debug.simPrintf("R: prijemBlankLine: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (States.endGETrequesta) {
					//debug.simPrintf("R: krajGETrequesta: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);

					//debug.simPrintf("tick %u, romMemorija.dataOut=%x, romMemorija.address=%u, sCurrentRomAddress=%u, sRomDataOutValid=%u\n", counter,romMemorija.dataOut,romMemorija.address,sCurrentROMAddress,sRomDataOutValid);
				}

				OTHERWISE {
				}
			}

			//debug.simPrintf("uriMemorija.writeEnable=%u, uriMemorija.dataIn=%x, uriMemorija.address=%u, sURIMEmoryWrite=%u, sCounter=%u, sNumericCurrent=%u, data=%x\n", uriMemorija.writeEnable,uriMemorija.dataIn,uriMemorija.address,sURIMemoryWrite,counter,sCurrentState,data);
			//debug.simPrintf("uriMemorija.DATAout=%x, sUriWordCount=%u, sCounter=%u\n", uriMemorija.dataOut,sUriWordCount,counter);

			IF(sCurrentState.eq(States.HttpVersion))
			{
				//sUriRamAddress.next<==sUriRamAddress+1;
				//uriMemorija.address<==sUriRamAddress;

				//debug.simPrintf("ISCITAVANJE: uriMemorija.DATAout=%x, uriMemorija.address=%u, sUriRamAddress=%u, sCounter=%u\n", uriMemorija.dataOut,uriMemorija.address, sUriRamAddress, counter);
				//debug.simPrintf("sUriSimpleHash=%u\n",sUriSimpleHash);
			}
		}
	}

	@Override
	protected void outputFunction() { //executes in current tick?
		//input.slice(base, width)

		//output <== data # mod # eof # sof # socket;//data # mod # eof # sof # socket;//# mod # eof # sof # socket //constant.value(dfeUInt(10), 0) # counter # input; //input.cast(dfeUInt(77))
		DFEsmValue rrrr = socket # sof # eof # mod # data; //when word is received, MaxJ has reversed the order of the fields in the input stream. why?
		//output <== socket # sof # eof # mod # constant.value(dfeUInt(64),55);//rrrr;//.cast(dfeUInt(77));
		//sCurrentState.next<==States.Headers;

		//output <== rrrr;//.cast(dfeUInt(77));
		//debug.simPrintf("tick %u, data=%x\n", counter,data);
		IF(input.valid)
		{
			debug.simPrintf("tick %u, data: %x, mod: %x, eof: %x, sof: %x, socket: %x, input.valid=%x, output.stall=%x, input.stall=%x\n", counter,data, mod, eof,sof,socket,input.valid,888, input.stall); //output.stall
			debug.simPrintf("tick %u, input: %x\n", counter,input);
			debug.simPrintf("tick %u, rrrr: %x\n", counter,rrrr);
			debug.simPrintf("tick %u, sCounter=%u, SNumericCurrent=%u, byte1=%x\n", counter,counter,sCurrentState,byte1);
			debug.simPrintf("rrrr", "%u", 1);
		}
		//output.valid <== sCurrentState===States.endGETrequesta; //counter>100000;//input.valid; //input.valid & input.valid; // counter>2000

//output.valid<== false;
//output <== 0;


		IF(~sOutputStall) //output.stall
		{

		}

		//dataLengthBytes<==((sEndROMAddress-1)-(sStartROMAddress+1) + 1)*8;
		//dataLengthBytes.valid<==true;

		//debug.simPrintf("tick=%u, output.valid=%x, output.stall=%x, dataFromMem.valid=%u\n",counter, output.valid,output.stall,dataFromMem.valid);

//		//signal for CPU: socket close
//		IF(sCloseSocketCycleFlag)
//		{
//
//			IF(sCloseSocketCycleCounter<17)
//			{
//				//posalji strim
//				//IF(~fromStateMachineDataSentFlag.stall)
//				{
//					fromStateMachineDataSentFlag.valid<==true;
//					fromStateMachineDataSentFlag<==socket;
//				}
//
//				debug.simPrintf("sCloseSocketCycleCounter=%u, Tick=%u\n",sCloseSocketCycleCounter,counter);
//			}
//		}

		//send data to FIFO URL buffer
//		storeUrlFifo.valid<==sHashZbirValid;
//		storeUrlFifo <== sHashZbirRegister.cast(dfeUInt(64+3+3)); //constant.value(dfeUInt(64+3+3), 200);



//		IF(dataFromMem.valid)
//		{
//			debug.simPrintf("BYTELENGTH Tick=%u, fromStateMachineByteNumber.valid=%x, fromStateMachineByteNumber=%u\n",sCounter,fromStateMachineByteNumber.valid,fromStateMachineByteNumber);
//		}

		checksumOutput.valid<==false;
		checksumOutput <== 0;

		IF(sStoreURLValid)
		{
			checksumOutput.valid<==true;
			checksumOutput <== sStoreURL.cast(dfeUInt(512));
		}


///input.stall <== output.stall;

//		String konstanta = String.format("%d", new BigInteger(1,"GE".getBytes())); //konvertuj string "GET " u hex oblik
//		System.out.println("Konvertovani oblik " + konstanta);
//		int width=32;
//		DFEsmValue methodBits = constant.value(dfeUInt(width),new BigInteger(1,"GET ".getBytes()));

		//smOutput <== sCounter;

//		//IF(sCurrentState===States.prijemURI)
//		{
//			//smOutput <== constant.value(dfeUInt(32), 55);
//			//smOutput <== sCounter;
//			//smOutput <== sHoldCounter;
//
//			//smOutput <== sCounter;
//			//smTest   <== sHoldCounter; //constant.value(dfeUInt(16), 47);
//			//smBajt   <== byte1;
//		}

		//smOutput <== byte1.cat(byte2).cast(dfeUInt(32));//sCounter;
		//smOutput <== byte1.cast(dfeUInt(32));//sCounter;


	}
}
