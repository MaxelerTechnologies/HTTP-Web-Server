package httpServer;

import java.math.BigInteger;

import com.maxeler.maxblox.statemachine.SMUtils;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.LMemCommandStream;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.managers.DFEManager;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmAssignableValue;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmMemAddress;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmSinglePortMappedROM;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateEnum;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateValue;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmValue;
import com.maxeler.maxcompiler.v2.statemachine.Latency;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushInput;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushOutput;
import com.maxeler.maxcompiler.v2.statemachine.manager.ManagerStateMachine;
import com.maxeler.maxcompiler.v2.statemachine.stdlib._State;

public class httpServerStateMachine extends ManagerStateMachine {

	enum Modes {
		COUNTING_UP, HOLD_COUNT, COUNTING_DOWN
	}

	enum States {
		start, // 0
		URI, // 1
		HttpVersion, // 2
		Headers, // 3
		CR, LF, BlankLine, endGETrequesta
		// receivingRequestLine, receivingURI,
		// receivingHttpVersion,receivingBlankLine,
	}

	enum StanjeCRLF {
		prijemCR, // 0
		prijemLF, // 1
		// receivingRequestLine, receivingURI,
		// receivingHttpVersion,receivingBlankLine,
	}

	enum MemoryOutState {
	}

	private enum MemCommand {
		NOP(0), ClearFlags(1), SetFlags(2), BlockUntilFlagsSet(4), BlockUntilFlagsCleared(
				5);

		private final int m_cmdCode;

		private MemCommand(int cmdCode) {
			m_cmdCode = cmdCode;
		}

		public int getInstructionCode() {
			return m_cmdCode;
		}
	}

	// state
	private final DFEsmStateValue counter = state.value(dfeUInt(20), 0); // 40
	private final DFEsmStateValue sDataPrevious = state.value(dfeUInt(64), 0);
	private final DFEsmStateValue sDataValid = state.value(dfeBool(), 0);
	// private final DFEsmStateValue sRunOneMoreTick = state.value(dfeBool(),
	// false);

	// private final DFEsmStateValue sOuputEmpty = state.value(dfeBool(), true);
	private final DFEsmStateValue sMemoryRead = state.value(dfeBool(), false);
	private final DFEsmStateValue sCurrentROMAddress = state.value(dfeUInt(32),
			0);
	//private final DFEsmStateValue sUriRamAddress = state.value(dfeUInt(7), 0);
	private final DFEsmStateValue sPrev2Bytes = state.value(dfeUInt(16), 0);
	private final DFEsmStateValue sPrev2BytesArray[] = new DFEsmStateValue[8];
	//private final DFEsmStateValue sURIMemoryWrite = state.value(dfeBool(),false);
	//private final DFEsmStateValue sDataPreValue = state.value(dfeUInt(64),0);
	//private final DFEsmStateValue sUriWordCount = state.value(dfeUInt(8), 0);
	//private final DFEsmStateValue sUriSimpleHash = state.value(dfeUInt(16), 0);

	private final DFEsmStateValue sHashIndexValid = state.value(dfeBool(),
			false);
	//private final DFEsmStateValue sRomHashIndexAddress = state.value(dfeUInt(15), 0);
	private final DFEsmStateValue sHashIndexDataOutValid = state.value(
			dfeBool(), false);
	private final DFEsmStateValue sStartROMAddress = state.value(dfeUInt(19), 0);
	private final DFEsmStateValue sEndROMAddress = state.value(dfeUInt(32), 0);

	private final DFEsmStateValue sRomDataOutValid = state.value(dfeBool(),
			false);
	private final DFEsmStateValue sRomAddressValid = state.value(dfeBool(),
			false);
	private final DFEsmStateValue sCurrentRomAddressInitialized = state.value(
			dfeBool(), false);

	private final DFEsmStateValue sOutputByteCounter = state.value(dfeUInt(11),
			0);
	private final DFEsmStateValue sOutputStall = state.value(dfeBool(), false);
	private final DFEsmStateValue sLMemBurstCounter = state.value(dfeUInt(19),
			0);
	private final DFEsmStateValue sBurstCounter = state.value(dfeUInt(19), 0);
	private final DFEsmStateValue sMemCmdOutputStall = state.value(dfeBool(),
			false);
	private final DFEsmStateValue sDataBurstLength = state
			.value(dfeUInt(19), 0);
	private final DFEsmStateValue sLMemBytesSent = state.value(dfeUInt(32), 0);
	private final DFEsmStateValue sFileLengthBytes = state
			.value(dfeUInt(26), 0);
	private final DFEsmStateValue sFileLengthBytesCounter = state.value(
			dfeUInt(26), 8);
	private final DFEsmStateValue sAllBytesSentFlag = state.value(dfeBool(),
			false);
	private final DFEsmStateValue sFileLengthBytesCounterMini = state.value(
			dfeUInt(8), 8);
	private final DFEsmStateValue sCloseSocketCycleCounter = state.value(
			dfeUInt(5), 1);
	private final DFEsmStateValue sCloseSocketCycleFlag = state.value(
			dfeBool(), false);
	private final DFEsmStateValue sByteNumberFlag = state.value(dfeBool(),
			false);
	private final DFEsmStateValue sStoreURL = state.value(dfeUInt(512), 0); // 192
	private final DFEsmStateValue sBitNumber = state.value(dfeUInt(9), 0);
	private final DFEsmStateValue sUseHashIndex = state.value(dfeUInt(1), 0);

	// State - state varibles
	private final DFEsmStateValue sCounter;
	private final DFEsmStateValue sNumericCurrentState;
	private final DFEsmStateValue sHoldCounter;
	private final DFEsmStateEnum<Modes> sMode;
	private final DFEsmStateEnum<States> sCurrentState;

	// LMem
	public static final String INPUT_MEM_DATA = "dataFromMem";
	public static final String OUTPUT_MEM_COMMAND = "memCmd";
	private final DFEStructType cmdType;
	private final DFEsmPushInput dataFromMem = io.pushInput(INPUT_MEM_DATA,
			dfeUInt(64), 1); // burstSizeBits
	private final DFEsmPushOutput memCmdOutput;
	private final DFEsmStateValue memCmdReg;
	private final DFEsmStateValue memCmdRegValid;
	// private final int writeStreamID;
	private final int readStreamID;

	// IO
	private final DFEsmPushInput input = io.pushInput("tcp_to_sm", dfeUInt(77),
			1); // UDP RX stream format: 748 bits
	private final DFEsmPushOutput output = io.pushOutput("stamped_tcp_frm_sm",
			dfeUInt(77), 1); // UDP TX stream format: 77 bits
	private final DFEsmPushOutput fromStateMachineByteNumber = io.pushOutput(
			"fromStateMachineByteNumber", dfeUInt(128), 5);
	private final DFEsmPushOutput checksumOutput = io.pushOutput(
			"checksumOutput", dfeUInt(512), 4);
	private final DFEsmPushInput checksumResult = io.pushInput(
			"checksumResult", dfeUInt(16), 1);

	//
	private final DFEsmValue byte1;
	private final DFEsmValue byte2;
	private final DFEsmValue byte3;
	private final DFEsmValue byte4;
	private final DFEsmValue byte5;
	private final DFEsmValue byte6;
	private final DFEsmValue byte7;
	private final DFEsmValue byte8;

	private final DFEsmStateValue sInputValid = state.value(dfeBool(), false);

	//private final DFEsmStateValue sHashZbirRegister = state.value(dfeUInt(15),0);
	//private final DFEsmStateValue sHashZbirValid = state.value(dfeBool(), false);

	DFEsmMemAddress adresaRom;

	private final DFEsmValue dataBytes[];
	// private final DFEsmValue zbir=constant.value(dfeUInt(8), 0);

	// BRAM memories
	// private final DFEsmSinglePortMappedROM romMemorija;

	private final DFEsmSinglePortMappedROM romHashIndex;
	private final DFEsmSinglePortMappedROM romHashIndex2;
	// ALTERA doesn't support READ_FIRST mode, WRITE_FIRST needs to be used
	// ISCA uses Altera chip
	// private final DFEsmSinglePortRAM uriMemorija = mem.ram(dfeUInt(64), 128,
	// SinglePortRAMMode.WRITE_FIRST, Latency.ONE_CYCLE);

	private final DFEsmValue data; //
	private final DFEsmValue mod;
	private final DFEsmValue eof;
	private final DFEsmValue sof;
	// private final DFEsmValue checksum_bad;
	private final DFEsmValue socket;

	public httpServerStateMachine(DFEManager owner, int readStreamID) {
		super(owner);

		// u konstruktoru se sa State varijabla radi sa '='
		// a u nextState() i OutputFunction() sa <== connect operatorom
		// ???????????????????????

		// put code in the contructor,
		// java class fields defined above (dostupna svim metodama unutar klase)

		// TCP rx/tx format: fields extraction
		data = input.slice(0, 64).cast(dfeUInt(64)); // bajt
		socket = input.slice(64, 8).cast(dfeUInt(8)); // bajt 11
		mod = input.slice(72, 3).cast(dfeUInt(3)); // bajt 1
		eof = input.slice(75, 1).cast(dfeUInt(1)); // bajt 1
		sof = input.slice(76, 1).cast(dfeUInt(1)); // bajt 1

		// UDP TX format stream:
		// name offset width(bits)

		// data 0 64
		// mod 64 3
		// eof 67 1
		// sof 68 1
		// socket 69 8
		// ===== 77

		// bits ordering: 77|76|75|...|63|...|4|3|2|1|0

		// State
		sMode = state.enumerated(Modes.class, Modes.COUNTING_UP);
		sCurrentState = state.enumerated(States.class, States.start);
		sCounter = state.value(dfeUInt(32), 0);
		sNumericCurrentState = state.value(dfeUInt(16), 0);
		sHoldCounter = state.value(dfeUInt(16), 0);

		for (int i = 0; i < sPrev2BytesArray.length; i++) {
			sPrev2BytesArray[i] = state.value(dfeUInt(8), 0);
		}

		dataBytes = new DFEsmValue[8];

		dataBytes[0] = data.slice(0, 8).cast(dfeUInt(8)); // #1
		dataBytes[1] = data.slice(8, 8).cast(dfeUInt(8)); // #2
		dataBytes[2] = data.slice(16, 8).cast(dfeUInt(8)); // #3
		dataBytes[3] = data.slice(24, 8).cast(dfeUInt(8)); // #4
		dataBytes[4] = data.slice(32, 8).cast(dfeUInt(8)); // #5
		dataBytes[5] = data.slice(40, 8).cast(dfeUInt(8)); // #6
		dataBytes[6] = data.slice(48, 8).cast(dfeUInt(8)); // #7
		dataBytes[7] = data.slice(56, 8).cast(dfeUInt(8)); // #8

		// extract all 64 bits at once in parallel
		byte1 = data.slice(0, 8).cast(dfeUInt(8)); // #1
		byte2 = data.slice(8, 8).cast(dfeUInt(8)); // #2
		byte3 = data.slice(16, 8).cast(dfeUInt(8)); // #3
		byte4 = data.slice(24, 8).cast(dfeUInt(8)); // #4
		byte5 = data.slice(32, 8).cast(dfeUInt(8)); // #5
		byte6 = data.slice(40, 8).cast(dfeUInt(8)); // #6
		byte7 = data.slice(48, 8).cast(dfeUInt(8)); // #7
		byte8 = data.slice(56, 8).cast(dfeUInt(8)); // #8

		// int r=7/0;;

		// HashIndex
		romHashIndex = mem.romMapped("romHashIndex1", dfeUInt(64), 32768,
				Latency.ONE_CYCLE);
		romHashIndex2 = mem.romMapped("romHashIndex2", dfeUInt(64), 32768,
				Latency.ONE_CYCLE);

		// ramMemorija.write(constant.var(0).cast(dfeUInt(10)),
		// constant.var(124).cast(dfeUInt(64)) , constant.var(true));
		// DFEVar outputData =
		// ramMemorija.read(constant.var(0).cast(dfeUInt(10)));
		//
		// //Java kod se izvrsi, pa se onda onda builduje .max file koji se
		// "spusta" na hardver
		// String text = "This text came from a FPGA";
		// int DATA_SIZE=text.length();
		// //byte niz[] = new byte[L]; //definise se niz duzine 1024 elementa
		// kod koga su elementi 1 bajt = 8 bita
		// Bits niz[] = new Bits[DATA_SIZE];
		//
		// //IF(data1===constant.var(dfeUInt(3),0)) //if ne radi u KERNEL-ima,
		// samo u State Machine-i
		//
		//
		// for(int i=0;i<DATA_SIZE;i++)
		// {
		// niz[i]=new Bits(8,text.charAt(i)); //inicijalizacija ROM memorije sa
		// inicijalnim vrednostima u vidu MaxJ Bits objekata
		// }
		// //Memory<DFEVar> romMemorija = mem.alloc(dfeUInt(8), DATA_SIZE);
		// //romMemorija.setContents(niz);
		//
		// int BrojBitaZaAdresiranje = MathUtils.bitsToAddress(DATA_SIZE);
		// System.out.println("Potreban broj bita za adresiranje " + DATA_SIZE +
		// " memorijskih lokacija je: " + BrojBitaZaAdresiranje);
		// //int y=7/0;

		// LMem
		cmdType = LMemCommandStream.getLMemCommandDFEStructType();

		// depth = depthBursts; //broj burstova,svaki od ovih burstova je
		// odredjenje velicine, obicno je burst=384 bajta
		// this.writeStreamID = writeStreamID;
		this.readStreamID = readStreamID;
		// this.basAddressBursts = basAddressBursts;

		memCmdReg = _State.value(state, dfeUInt(cmdType.getTotalBits()),
				"memCmdReg");
		memCmdRegValid = _State
				.value(state, dfeBool(), false, "memCmdRegValid");
		memCmdOutput = io.pushOutput(OUTPUT_MEM_COMMAND,
				dfeUInt(cmdType.getTotalBits()), 1);
	}

	@Override
	protected void nextState() { //executes in next tick?

		//LMem section
		memCmdRegValid.next <== false;
		sMemCmdOutputStall.next<==memCmdOutput.stall;
//
		IF(dataFromMem.valid) //LMem
		{
			sLMemBytesSent.next<==sLMemBytesSent+8;
			sFileLengthBytesCounter.next<==sFileLengthBytesCounter+8;
			sFileLengthBytesCounterMini.next<==sFileLengthBytesCounterMini+8;

			//debug.simPrintf("Tick=%u, sLMemBurstCounter=%u, Podaci sa LMem dataFromLMem.valid=%x, dataFromLMem=%x,\n",counter,sLMemBurstCounter,dataFromMem.valid, dataFromMem)

			IF(sFileLengthBytesCounter>=sFileLengthBytes)
			{
				sAllBytesSentFlag.next<==true;
			}

//			//for disconnect
//			IF(sFileLengthBytesCounter>=sFileLengthBytes)
//			{
//				IF(~sAllBytesSentFlag)
//				{
//					sCloseSocketCycleFlag.next<==true;
//				}
//			}

			IF(~sByteNumberFlag)
			{
				sCloseSocketCycleFlag.next<==true;
				sByteNumberFlag.next<==true;
			}

			IF(sFileLengthBytesCounterMini===192)
			{
				sBurstCounter.next<==sBurstCounter+1;
				sFileLengthBytesCounterMini.next<==8;

				debug.simPrintf("Tick=%u, sBurstCounter=%u\n",counter,sBurstCounter);
			}
		}

		IF(sBurstCounter===sDataBurstLength)
		{
			sLMemBytesSent.next<==0;
			sAllBytesSentFlag.next<==false;
			sFileLengthBytesCounter.next<==8;
			sBurstCounter.next<==0;
			sDataBurstLength.next<==1;
			sByteNumberFlag.next<==false;

			debug.simPrintf("Tick=%u, sBurstCounter===sDataBurstLength\n",counter);
		}

//		IF(sCloseSocketCycleFlag)
//		{
//			sCloseSocketCycleCounter.next<==sCloseSocketCycleCounter+1;
//			IF(sCloseSocketCycleCounter===16)
//			{
//				sCloseSocketCycleFlag.next<==false;
//				sCloseSocketCycleCounter.next<==1;
//			}
//		}

		IF(sCloseSocketCycleFlag)
		{
			sCloseSocketCycleFlag.next<==false;
		}

		IF((sMemoryRead===true))
		{
			IF((~memCmdOutput.stall)) //~memCmdOutput.stall
			{
				sLMemBurstCounter.next<==sLMemBurstCounter+1;
				//debug.simPrintf("Tick=%u, IZVRSAVAM read komandu\n",counter);
				makeReadOrWriteCommand(memCmdReg, //referenca ka objektu,adresa=base + x, streamID
						//constant.value(dfeUInt(32), 0), //basAddressBursts+ memWriteCommitPointer.cast(dfeUInt(32)
						(sStartROMAddress+sLMemBurstCounter).cast(dfeUInt(32)), //adresaRom ie. burst number
						readStreamID); //readStreamID

				memCmdRegValid.next <== true;

				IF(sLMemBurstCounter.eq(sDataBurstLength-1))
				{
					sMemoryRead.next<==false;
					sRomAddressValid.next<==false;
					sCurrentState.next<==States.start; //after memory was read, change current state;
					sCurrentROMAddress.next<==0;
					sRomDataOutValid.next<==0;

					sLMemBurstCounter.next<==0;
					debug.simPrintf("Poslata poslednja LMem read komanda, sLMemBurstCounter=%u\n", sLMemBurstCounter);
				}
			}
		}

		sOutputStall.next<==output.stall;
		//IF(output.stall===true) sOutputStall.next<==true;

		IF(~output.stall) //output.stall
		{

//			DFEsmAssignableValue hashZbir = assignable.value(dfeUInt(15));
//			IF(sHashZbirValid===true)
//			{
//				hashZbir<==sHashZbirRegister;
//				sHashZbirValid.next<==false;
//				debug.simPrintf("Vrednost sHashZbirRegistra=%u\n", sHashZbirRegister);
//			}
//			ELSE
//			{
//				hashZbir<==0;
//			}

			sInputValid.next <== input.valid;

	     	//value assignments
			counter.next <== counter + 1;
			sDataPrevious.next <== data;
			sDataValid.next <== input.valid;

			//sPrev2BytesPoslednja.next <== byte8 # byte7; //2 bytes from the previous cycle
			sPrev2Bytes.next <== byte8 # byte7;

			for(int i=0;i<sPrev2BytesArray.length;i++)
			{
				sPrev2BytesArray[i].next<==dataBytes[i];
			}

			//u ciklusu kada je stanje endGETrequest, znaci da je ulazni request prepoznan
			//to znaci da se odgovor moze poslati klijentu
			//zato u osmatranom trenutku podesi kontrolni signal
			//tako da se vec od sledeceg trenutka pocne sa iscitavanjem podataka
			//iz memorije i slanje ka klijentu
			IF(sCurrentState===States.endGETrequesta)
			{
				sMemoryRead.next <==true; //od sledeceg trenutka ovaj kontrolni signal (inace varijabla stanja) ce imati vrednost true
				sCurrentState.next<==States.start;
			}

			//DFEsmMemAddress adresaRom = romMemorija.address;

			IF((sMemoryRead===true) & (sCurrentRomAddressInitialized===true)) //i hash je bio valid i stanje je bilo endGetRequest
			{
				sCurrentROMAddress.next<==sCurrentROMAddress+1;
				//romMemorija.address <== sCurrentROMAddress.cast(dfeUInt(MathUtils.bitsToAddress(Depth)));//constant.value(dfeUInt(13), 0);
				//debug.simPrintf("tick=%u, IZVRSAVAM\n", counter);
				//debug.simPrintf("tick %u, romMemorija.dataOut=%x, romMemorija.address=%u, sCurrentRomAddress=%u, sRomDataOutValid=%u\n", counter,romMemorija.dataOut,romMemorija.address,sCurrentROMAddress,sRomDataOutValid);

				//sMemoryRead.next<==false;
				//sRomAddressValid.next<==true;
				sRomDataOutValid.next<==true;
			};

			//		IF(sRomAddressValid===true)
			//		{
			//			sRomDataOutValid.next<==true;
			//			sRomAddressValid.next<==false;
			//		}

			IF(sCurrentROMAddress.eq(sEndROMAddress-1))
			{
//					sMemoryRead.next<==false;
//
//					sRomAddressValid.next<==false;
//					sCurrentState.next<==States.start; //after memory was read, change current state;
//					sCurrentROMAddress.next<==0;
//					sRomDataOutValid.next<==0;
//					debug.simPrintf("Iscitana poslednja adresa, adresa=%u\n", sCurrentROMAddress);
			}

			IF(checksumResult.valid)
			{
				debug.simPrintf("checksumResult.valid=1\n");

				romHashIndex.address <== checksumResult.slice(0, 15);     //sRomHashIndexAddress.slice(0, 15);
				romHashIndex2.address <== checksumResult.slice(0, 15);    //sRomHashIndexAddress.slice(0, 15);
				sUseHashIndex.next <== checksumResult[15];

				debug.simPrintf("checksumResult.slice(0, 15)=%u, sUseHashIndex.next=%u\n",checksumResult.slice(0, 15),checksumResult[15]);

				sHashIndexDataOutValid.next<==true;
			}

			IF(sHashIndexValid===true)
			{
				sHashIndexValid.next <== false;
			}

//			IF(sHashIndexValid===true)
//			{
//				//DFEsmAssignableValue ttt=assignable.value(dfeUInt(64));
//				//sRomHashIndexAddress.next<==sRomHashIndexAddress+1;
//
//				romHashIndex.address <== ;     //sRomHashIndexAddress.slice(0, 15);
//				romHashIndex2.address <== ;    //sRomHashIndexAddress.slice(0, 15);
////
//				IF(sRomHashIndexAddress[14]===0)
//				{
//					//case 1: first bit is 0 -> use romHashIndex
//					//case 2: first bit is 1 -> use romHashIndex2
//					// <== ;
//
//					 <== romHashIndex.dataOut;
//				}
//				ELSE //if sRomHashIndexAddress[15]===1
//				{//
////					 <== romHashIndex2.dataOut;
//				}
//
//				//romHashIndex.address<==sRomHashIndexAddress;
//				//debug.simPrintf("Postavljam romHashIndex.address na=%u, current=%u\n", sRomHashIndexAddress,counter);
//				//sHashIndexValid.next<==false;
//				//ttt<==romHashIndex.dataOut;
//				//sHashIndexDataOutValid.next<==true;
//				debug.simPrintf("Vrednost romHashIndex.dataOut=%x, romHashIndex.dataOut=%x, current=%u\n", romHashIndex.dataOut, romHashIndex2.dataOut, counter);
//
//				romHashIndex.address<==12;//sRomHashIndexAddress;
//				debug.simPrintf("Postavljam romHashIndex.address na=%u, current=%u\n", sRomHashIndexAddress,counter);
//				sHashIndexValid.next<==false;
//				//ttt<==romHashIndex.dataOut;
//				sHashIndexDataOutValid.next<==true;
//				debug.simPrintf("Vrednost romHashIndex.dataOut=%x, current=%u\n", romHashIndex.dataOut,counter);
//
//				// romHashIndex.dataOut;
//
//				//          sMemoryRead.next<==false;
//				//          sCurrentState.next<==States.start; //after memory was read, change current state;
//				//          sCurrentROMAddress.next<==0;
//				//          debug.simPrintf("Iscitana poslednja adresa, adresa=%u", sCurrentROMAddress);
//			}

			IF(sHashIndexDataOutValid===true) //
			{

				DFEsmAssignableValue hashIndexData = assignable.value(dfeUInt(64));
				hashIndexData <== 0;

				IF(sUseHashIndex===0)
				{
					hashIndexData <== romHashIndex.dataOut;
				}
				ELSE
				{
					hashIndexData <== romHashIndex2.dataOut;
				}

				debug.simPrintf("Vrednost romHashIndex.dataOut=%x, romHashIndex.dataOut=%x, sUseHashIndex=%x, current=%u\n", romHashIndex.dataOut, romHashIndex2.dataOut, sUseHashIndex, counter);

				DFEsmAssignableValue startAddressBurst=assignable.value(dfeUInt(19)); //startAddressBurst in LMem
				DFEsmAssignableValue fileLengthBursts=assignable.value(dfeUInt(19)); //length of a file as number of Bursts
				DFEsmAssignableValue fileLengthBytes=assignable.value(dfeUInt(26));  // 2^26 / 1024 /1024 = 64 MB, ali ovo ipak nije celobrojan broj Burstova, poslednji burst nece biti zauzet do kraja

				fileLengthBytes<==hashIndexData.slice(0, 26); //romHashIndex.dataOut.slice(0, 26); //file length + ResponseHeaderlength(56 bytes)
				fileLengthBursts<==hashIndexData.slice(26, 19); //romHashIndex.dataOut.slice(26, 19);
				startAddressBurst<==hashIndexData.slice(45, 19); //romHashIndex.dataOut.slice(44, 19);

				debug.simPrintf("startAddressBurst=%u, fileLengthBursts=%u, fileLengthBytes=%u\n",startAddressBurst,fileLengthBursts,fileLengthBytes);

				//LMem
				sStartROMAddress.next<==startAddressBurst;
				sDataBurstLength.next<==fileLengthBursts;
				sFileLengthBytes.next<==fileLengthBytes;

				sHashIndexDataOutValid.next<==false;

				//debug.simPrintf("addressByte1=%u, addressByte2=%u, addressByte3=%u, addressByte4=%u\n",addressByte1,addressByte2,addressByte3,addressByte4);
				//debug.simPrintf("VALID romHashIndex, romHashIndex.dataOut=%x, startAddress=%u,addressNumber=%u, current=%u\n", romHashIndex.dataOut,startAddress,addressNumber,counter);
			}

			IF(sRomDataOutValid===true)
			{
				sOutputByteCounter.next<==sOutputByteCounter+1; //number of bytes sent to output port
				//debug.simPrintf("tick=%u, sRomDataOutValid=%u, sOutputByteCounter=%u\n",counter,sRomDataOutValid, sOutputByteCounter);
			}

			counter.next<==counter+1;

			//		IF(sEndOfReading)
			//		{
			//			sCurrentState.next<==States.start;
			//		}

			//IF((sCurrentROMAddress))

			//case structures
			//IF(input.valid)
			//debug.simPrintf("Tick: %u, sRunOneMoreTick=%u, eof=%x **********\n", counter,sRunOneMoreTick,input.slice(67, 1).cast(dfeUInt(1)));
			//IF(counter>110000) counter.next<==0;

			//IF(input.valid) sRunOneMoreTick.next<==constant.value(dfeBool(),tr);

			//IF(input.valid) counter.next<==0;

			//HTTP request: opsti oblik
			// 1) request-line
			// 2) headers (0 or more)
			// 3) <blank line>
			// 4) body (only for a POST method)

			// URI requests:
			// / -> index.html
			// index.html -> index.html

			int width=32;
			//DFEsmValue headerMethod = smInput.slice(0, width).cast(dfeUInt(width)); // 1|2|3|4|5|6|7|8 => 8|7|6|5|4|3|2|1 posle slice funkcije
			// zasto menja raspored BAJTOVA (ne bitova)?

			//DFEVectorType<DFEsmValue> vector = new DFEVectorType<DFEsmValue>(dfeUInt(8), 8);
			//DFEVector<DFEVar> dataBytes = vector.newInstance(this);

			DFEsmValue methodGET = constant.value(dfeUInt(width),new BigInteger(1,"GET ".getBytes()));

			IF(input.valid)
			{
				//IF(sRunOneMoreTick===true) sRunOneMoreTick.next<==false;
				SWITCH(sCurrentState)
				{
					CASE(States.start)
					{
						//for(int i=0;i<8;i++) //loop unrolling, petlja se pretvara u 8 blokova koji se paralelno izvrsavaju

						//debug.simPrintf("INDEX: startIndex=%u, startIndexFound=%u, endIndex=%u, endIndexFound=%u\n", startIndex,startIndexFound,endIndex,endIndexFound);

						//if zbir>=2, krenuti sa pretragom od prvog indexa space
						//kad detektujem prvi space, to znaci da sledeci bajt nakon njega pocinje startURI
						//sve dok ne detektujem drugi uzastopni space, URI je validan
						//kada se detektuje space to znaci da je bajt iza njega krajURI

						//debug.simPrintf("prijemRequestMethod: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						//DFEsmValue N4bajta = byte1 # byte2 # byte3 # byte4;
						DFEsmValue N4bajta = byte1 # byte2 # byte3 # byte4;
						DFEsmAssignableValue zbir = assignable.value(dfeUInt(4));
						zbir <== 0;

						IF (N4bajta === methodGET) { //condition to move to a next state

							IF(byte4===' ') //space IF sa promenljivima ne RADI kako treba, prolazi cak i kad nije ispunjen uslov
							{
								//sURIMemoryWrite.next<==true;
								//kada se postavi na TRUE, drzi vrednost samo jedan ciklus???? resetuje se posle svakog ciklusa na FALSE
								//uriMemorija.writeEnable<==true; //primljen PRVI space, oznacava da pocinje URI
								//uriMemorija.dataIn<==data;
								//uriMemorija.address<==sUriRamAddress;
								//sUriRamAddress.next<==sUriRamAddress+1;

								DFEsmAssignableValue startIndex=assignable.value(dfeUInt(3));
								startIndex<==7;
								DFEsmAssignableValue endIndex=assignable.value(dfeUInt(3));
								endIndex<==0;

								for(int i=0;i<8;i++)
								{
									IF(dataBytes[i]===' ') //parallel sum
									{
										IF(i<startIndex)
										{
											startIndex<==i;
										}

										IF((i>endIndex)) //(startIndex<endIndex)
										{
											endIndex<==i;
										}

										zbir<==zbir+1;
									}
								}

								IF(zbir>=2)
								{
									//ako je zbir>=2
									//to znaci da je URI poceo i zavrsio se
									//u tekucem ciklusu
									//pronadjen je i startIndex i endIndex
									//moze da se izracuna hash na bajtovima
									//izmedju startIndex i endIndex
									startIndex<==startIndex+1;
									endIndex<==endIndex-1;

									debug.simPrintf("ZBIR>=2, startIndex=%u, endIndex=%u\n",startIndex,endIndex);

								}
								ELSE
								{
									//ako je zbir=0 ili zbir=1,
									//to znaci da je URI (zbir=1) samo zapocet u tekucem ciklusu
									//onda nema potrebe da se vrednost smanjuje za 1
									//startIndex uvecaj za jedan kako bi dobio index bajta
									//od koga pocinje URI
									//kako se URI ne zavrsava u tekucoj word, onda endIndex
									//dodeli vrednost 7m jer jos nije kraj URIja

									//IF(startIndex===7) startIndex<==0;
									//IF(endIndex===0) endIndex<==7;

									startIndex<==startIndex+1;
									endIndex<==7;

								}

								debug.simPrintf("ZBIR zbir=%u, startIndex=%u, endIndex=%u\n",zbir,startIndex,endIndex);

								DFEsmAssignableValue bytes[]=new DFEsmAssignableValue[8];
								for(int u=0;u<8;u++)
								{
									bytes[u]=assignable.value(dfeUInt(8));
									bytes[u]<==dataBytes[u];
									IF(dataBytes[u]===' ')
									{
										bytes[u]<==0;
									}
								}

								for(int t=0;t<8;t++)
								{
									//debug.simPrintf("ZBIR blank[0]=%u, blank[3]=%u, blank[5]=%u, Broj spaceova=%u\n", blank[0],blank[3], blank[5],zbir);
									debug.simPrintf("ZBIR stanje Start bytes[%d]=%u\n",t,bytes[t]);
								}

								debug.simPrintf("Ulaz u doHash funkciju startIndex=%u, endIndex=%u\n",startIndex,endIndex);
								//doHashFunction(hashZbir, bytes,startIndex,endIndex);

								DFEsmAssignableValue startIndexBit = assignable.value(dfeUInt(8));
								DFEsmAssignableValue endIndexBit = assignable.value(dfeUInt(8));
								startIndexBit <== startIndex.cast(dfeUInt(8))*8;
								endIndexBit <== endIndex.cast(dfeUInt(8))*8+7;

								DFEsmAssignableValue bitNumber = assignable.value(dfeUInt(9));
								bitNumber <==0;

								int bitPointer = 0;

								for(int i=0;i<8;i++)
								{
									IF((i>=startIndex) & (i<=endIndex))
									{
											for(int j=0;j<8;j++)
											{
												SWITCH(bitNumber)
												{
													CASE(0) {
														sStoreURL.next[0+j] <== bytes[i].slice(j, 1);
													}

													CASE(8) {
														sStoreURL.next[8+j] <== bytes[i].slice(j, 1);
													}

													CASE(16) {
														sStoreURL.next[16+j] <== bytes[i].slice(j, 1);
													}

													CASE(24) {
														sStoreURL.next[24+j] <== bytes[i].slice(j, 1);
													}

													CASE(32) {
														sStoreURL.next[32+j] <== bytes[i].slice(j, 1);
													}

													CASE(40) {
														sStoreURL.next[40+j] <== bytes[i].slice(j, 1);
													}

													CASE(48) {
														sStoreURL.next[48+j] <== bytes[i].slice(j, 1);
													}

													CASE(56) {
														sStoreURL.next[56+j] <== bytes[i].slice(j, 1);
													}
												}
											}
										bitNumber <== bitNumber + 8;
									}

									bitPointer=bitPointer+8;

									debug.simPrintf("TEST: bitPointer=%u\n", bitPointer);
								}

								debug.simPrintf("TEST: startIndex=%u, endIndex=%u, startIndexBit=%u, endIndexBit=%u, bitNumber=%u, sStoreURL=%x\n", startIndex, endIndex, startIndexBit, endIndexBit, bitNumber, sStoreURL);
								//debug.simPrintf("Racunam hashZbir u stanju Start hashZbir=%u\n", hashZbir);

								sBitNumber.next <== bitNumber;

								//sUriSimpleHash.next<==(byte5+byte6+byte7+byte8).cast(dfeUInt(16));
								//sUriWordCount.next<==sUriWordCount+1; //nakon svakog upisavanja, uvecaj counter RECI za 1
							}

							IF(zbir>=2) //od indexa 4 do index 7, ako je bio
							//IF(byte5===' ' | byte6===' ' | byte7===' ' | byte8===' ') //in current word, also URI was received
							{
								//to znaci da je deo HTTP dela primljen vec u tekucem ciklusu
								//i taj deo treba procesirati tj obraditi i analizirati
								sCurrentState.next<==States.HttpVersion;
								debug.simPrintf("nextState: prijemHttpVersion: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);

								//izracunati hash se moze smatrati validnim pocev od narednog ciklusa
								//sHashZbirFinal.next<==true;
							}
							ELSE {
								//1) postavi da se u sledecem ciklusu predje u URI stanje
								//2) u tekucem ciklusu izracunaj hash
								sCurrentState.next<==States.URI;
								//sHashZbirRegister.next<==hashZbir; //presi hashZbir u sledeci ciklus, jer DFEsmAssignableValue ne moze izmedju ciklusa
								//sHashZbirValid.next<==true;
								//debug.simPrintf("nextState: prijemURI: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
							}
						}
					}
					CASE(States.URI)
					{
						DFEsmAssignableValue sumStateURI = assignable.value(dfeUInt(4));
						sumStateURI <== 0;
						DFEsmAssignableValue startIndex=assignable.value(dfeUInt(3));
						startIndex<==0;
						DFEsmAssignableValue endIndex=assignable.value(dfeUInt(3));
						endIndex<==0;

						debug.simPrintf("TEST: sBitNumber=%u, sStoreURL=%x\n", sBitNumber, sStoreURL);

						for(int i=0;i<8;i++)
						{
							IF(dataBytes[i]===' ')
							{
								IF((i>endIndex))
								{
									endIndex<==i;
								}

								sumStateURI<==sumStateURI+1;
							}
						}

						IF(sumStateURI>=2)
						{
							startIndex<==startIndex+1;
							endIndex<==endIndex-1;

							debug.simPrintf("ZBIR>=2, startIndex=%u, endIndex=%u\n",startIndex,endIndex);

						}
						ELSE IF(sumStateURI===1)
						{
							//IF(startIndex===7) startIndex<==0;
							//IF(endIndex===0) endIndex<==7;

							//startIndex<==startIndex+1;
							IF(endIndex!==0) endIndex<==endIndex-1;
						}
						ELSE IF(sumStateURI===0)
						{
							startIndex<==0;
							endIndex<==7;
						}

						DFEsmAssignableValue bytes[]=new DFEsmAssignableValue[8];
						for(int u=0;u<8;u++)
						{
							bytes[u]=assignable.value(dfeUInt(8));
							bytes[u]<==dataBytes[u];
							IF(dataBytes[u]===' ')
							{
								bytes[u]<==0;
							}
						}

						for(int t=0;t<8;t++)
						{
							//debug.simPrintf("ZBIR blank[0]=%u, blank[3]=%u, blank[5]=%u, Broj spaceova=%u\n", blank[0],blank[3], blank[5],zbir);
							debug.simPrintf("ZBIR stanje URI bytes[%d]=%u\n",t,bytes[t]);
						}

						debug.simPrintf("STANJE URI: Ulaz u doHash funkciju startIndex=%u, endIndex=%u\n",startIndex,endIndex);
						//doHashFunction(hashZbir,bytes,startIndex,endIndex);

						DFEsmAssignableValue bitNumber = assignable.value(dfeUInt(9));
						bitNumber <==sBitNumber;

						int bitPointer = 0;

						for(int i=0;i<8;i++)
						{
							IF((i>=startIndex) & (i<=endIndex))
							{
								for(int t=0;t<504;t++)
								{
									IF(bitNumber===t)
									{
										for(int j=0;j<8;j++)
										{
											sStoreURL.next[t+j] <== bytes[i].slice(j, 1);
											//copyStoreURL.slice(t+j, 1) <== bytes[i].slice(j, 1);
										}

										debug.simPrintf("TEST bytes: bytes=%x\n", bytes[i]);

										//sStoreURL.next[alignRight+j] <== bytes[i].slice(j, 1);
									}
								}

								bitNumber <== bitNumber + 8;
							}

							bitPointer=bitPointer+8;

							debug.simPrintf("TEST: bitPointer=%u\n", bitPointer);
						}

						debug.simPrintf("TEST URL: startIndex=%u, endIndex=%u, bitNumber=%u, sStoreURL=%x\n", startIndex, endIndex, bitNumber, sStoreURL);
						//debug.simPrintf("Racunam hashZbir u stanju Start hashZbir=%u\n", hashZbir);

						sBitNumber.next<==bitNumber;

						//debug.simPrintf("Racunam hashZbir u stanju URI hashZbir=%u\n", hashZbir);

						//ako je sistem u stanju prijema URIja onda, kad detektujes blank predji u stanje prijema Http verzije
						//url koji se prosledjuju requestom: da li je case-sensitive ili ne??? pogledati rfc
						//debug.simPrintf("prijemURI: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						IF (byte1===' ' | byte2===' ' | byte3===' ' | byte4===' ' | byte5===' ' | byte6===' ' | byte7===' ' | byte8===' ')
						{
							//ako je detektovan space => oznacava kraj URI, dalje sleduje HTTP deo
							//dva slucaja:
							// 1) HTTP deo pocinje i zavrsava se u trenutnoj WORD => tada odmah mozes da predjes u stanje koje ide nakon HTTP
							// 2) HTTP deo samo pocinje => tada si od sledece ciklusa u stanju HTTP

							//URI sigurno ne sadrzi blankove (blank se zamenjuje sa %20 ili nekim safe karakterom)
							//pa je blank iza URIja (metoda+blank je ispitano u prijemMetodi
							sCurrentState.next<==States.HttpVersion;
							//sUriRamAddress.next<==0;

							//sHashZbirRegister.next<==hashZbir;
							sHashIndexValid.next<==true; //since end of URI is detected, set valid flag to true value
							//sRomHashIndexAddress.next<==hashZbir;

							//uriMemorija.writeEnable<==true; //ako je stanje URI, onda to znaci da su primljene bar 2 words u razlicitim ciklusima
							//ako je detektovan SPACE (hex 20) onda to znaci da se u ovoj reci zavrsava URI, stigao zavrsni SPACE
							//iskljuci upisivanje u memoriju

							debug.simPrintf("nextState: prijemHttpVersion: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						}
						ELSE{
							//sve dok si u stanju URI, upisuj trenutni podatak u memoriju, povecavaj adresu
							//drugi deo kod definisace prelazak u sledece stanje
							//sUriRamAddress.next<==sUriRamAddress+1;

							sCurrentState.next<==States.URI;
							//sHashZbirRegister.next<==hashZbir; //presi hashZbir u sledeci ciklus, jer DFEsmAssignableValue ne moze izmedju ciklusa
							//sHashZbirValid.next<==true;
						}
					}
					CASE(States.HttpVersion)
					{
						//sCurrentState.next<==States.prijemRequestMethod;

						//debug.simPrintf("prijemHttpVersion: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);

						//kraj HTTP verzije se detektuje sa CRLF sekvencom, tako je prema RFC standardu
						//CR+LF, '\r\n', 0x0D0A (CR=13dec LF=10d)
						//					IF (byte1===13 | byte2===13 | byte3===13 | byte4===13 | byte5===13 | byte6===13 | byte7===13 | byte8===13)
						//					{
						//						//ako je detektovan space ' '
						//						//predji u stanje prijema HTTP
						//						//URI sigurno ne sadrzi blankove (blank se zamenjuje sa %20 ili nekim safe karakterom)
						//						//pa je blank iza URIja (metoda+blank je ispitano u prijemMetodi)
						//						sCurrentState.next<==States.prijemLF;
						//						sHoldCounter.next<==8;
						//
						//						debug.simPrintf("nextState: prijemLF: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						//
						//						//sHoldCounter.next<==3;
						//
						//					}

						//					for(int i=0;i<7;i++) //loop unrolling, petlja se pretvara u 8 blokova koji se paralelno izvrsavaju
						//					{
						//						IF(dataBytes[i]===13 & dataBytes[i+1]===10)
						//						{
						//							sCurrentState.next<==States.BlankLine;
						//							//pronadjen===true;
						//							//debug.simPrintf("nextState: prijemBlankLine: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						//						}
						//					}

						debug.simPrintf("TEST httpState: sBitNumber=%u, sStoreURL=%x\n", sBitNumber, sStoreURL);

						//bezuslovna detekcija dva uzastopna CRLF karaktera
						//1) 2 uzastopna u current WORD
						//2)  uzastopni iz predthodne i tekuce WORD

						//oznacava kraj Requesta, koristiti samo kad se zeli detektovati kraj requesta bez prolaska kroz ostala stanja
						debug.simPrintf("U HTTP stanju: byte1=%x, byte2=%x, sPrev2Bytes=%x\n",byte1,byte2,sPrev2Bytes);
						IF(input.valid)
						{
							//2 bajta iz prethodnog ciklusa da li su jednaka sa pocetnim bajtovima
							IF (byte1===13 & byte2===10)
								IF (sPrev2Bytes === (byte2 # byte1))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 1: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							//0p,1p sa 0,1 - p: prethodno
							//5p,6p,7p sa 0
							//7p sa 0,1,2

							//0p,1p sa 0,1 - p: prethodno
							IF (byte1===13 & byte2===10) //ako su u prethnodnom ciklusu stigla samo dva bajta i to bas CRLF
								IF ((sPrev2BytesArray[1] # sPrev2BytesArray[0]) === (byte2 # byte1))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 7: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							//5p,6p,7p sa 0
							IF ((sPrev2BytesArray[5]===13) & (sPrev2BytesArray[6] === 10))
								IF ((sPrev2BytesArray[7] === 13) & (byte1===10))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 8: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							//7p sa 0,1,2
							IF ((sPrev2BytesArray[7]===13) & (byte1 === 10))
								IF ((byte2 === 13) & (byte3===10))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 9: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							//u trenutnoj word da li su prisutne 2 susedna CRLF
							IF (byte1===13 & byte2===10)
								IF ((byte1 # byte2) === (byte3 # byte4))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 2: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							IF (byte2===13 & byte3===10)
								IF ((byte2 # byte3) === (byte4 # byte5))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 3: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							IF (byte3===13 & byte4===10)
								IF ((byte3 # byte4) === (byte5 # byte6))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 4: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							IF (byte4===13 & byte5===10)
								IF ((byte4 # byte5) === (byte6 # byte7))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 5: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							IF (byte5===13 & byte6===10)
								IF ((byte5 # byte6) === (byte7 # byte8))
								{
									sCurrentState.next<==States.endGETrequesta;
									debug.simPrintf("nextState 6: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}
						}
					}
					CASE(States.LF) //obrisati prijemCR
					{
						//sCurrentState.next<==States.prijemRequestMethod;
						//debug.simPrintf("prijemLF: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);

						//kraj HTTP verzije se detektuje sa CRLF sekvencom, tako je prema RFC standardu
						//CR+LF, '\r\n', 0x0D0A (CR=13dec LF=10d)
						//IF (byte1===10 | byte2===10 | byte3===10 | byte4===10 | byte5===10 | byte6===10 | byte7===10 | byte8===10)
						{
							//ako je detektovan space ' '
							//predji u stanje prijema HTTP
							//URI sigurno ne sadrzi blankove (blank se zamenjuje sa %20 ili nekim safe karakterom)
							//pa je blank iza URIja (metoda+blank je ispitano u prijemMetodi

							for(int i=0;i<7;i++) //loop unrolling, petlja se pretvara u 8 blokova koji se paralelno izvrsavaju
							{
								IF(dataBytes[i]===13 & dataBytes[i+1]===10)
								{
									//sCurrentState.next<==States.endGETrequesta;
									//debug.simPrintf("nextState: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}
							}

							sCurrentState.next<==States.BlankLine;

							//debug.simPrintf("nextState: prijemBlankLine: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						}
					}
					CASE(States.BlankLine) //blank linija je samo CRLF, jedan do drugog
					{
						//za jednostavan slucaj GET requesta HTTP-a, treba ignorisati sve headere

						//debug.simPrintf("prijemBlankLine: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);

						//				IF (byte1===10 | byte2===10 | byte3===10 | byte4===10 | byte5===10 | byte6===10 | byte7===10 | byte8===10)
						//				{
						//					//ako je detektovan space ' '
						//					//predji u stanje prijema HTTP
						//					//URI sigurno ne sadrzi blankove (blank se zamenjuje sa %20 ili nekim safe karakterom)
						//					//pa je blank iza URIja (metoda+blank je ispitano u prijemMetodi
						//					sCurrentState.next<==States.prijemBlankLine;
						//				}

						for(int i=0;i<7;i++) //loop unrolling, petlja se pretvara u 8 blokova koji se paralelno izvrsavaju
						{
							IF(dataBytes[i]===13 & dataBytes[i+1]===10)
							{
								//sCurrentState.next<==States.endGETrequesta;
								//debug.simPrintf("nextState: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
							}
						}
					}

					CASE(States.endGETrequesta)
					{
						//ako je detektovan kraj HTTP requesta onda mozes da predjes na dohvatanje podataka i vracanja HTTP responsa
						//simple case: vrati odredjenu vrednost promenljive nazad
						//debug.simPrintf("krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
					}
				} //end switch
			}

			SWITCH (sCurrentState) {
				CASE (States.start) {
					//debug.simPrintf("R: prijemStart: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (States.URI) {
					//debug.simPrintf("R: prijemURI: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (States.HttpVersion) {
					//debug.simPrintf("R: prijemHttpVersion: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (States.CR) {
					//debug.simPrintf("R: prijemCR: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (States.LF) {
					//debug.simPrintf("R: prijemLF: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (States.BlankLine) {
					//debug.simPrintf("R: prijemBlankLine: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (States.endGETrequesta) {
					//debug.simPrintf("R: krajGETrequesta: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);

					//debug.simPrintf("tick %u, romMemorija.dataOut=%x, romMemorija.address=%u, sCurrentRomAddress=%u, sRomDataOutValid=%u\n", counter,romMemorija.dataOut,romMemorija.address,sCurrentROMAddress,sRomDataOutValid);
				}

				OTHERWISE {
				}
			}

			//debug.simPrintf("uriMemorija.writeEnable=%u, uriMemorija.dataIn=%x, uriMemorija.address=%u, sURIMEmoryWrite=%u, sCounter=%u, sNumericCurrent=%u, data=%x\n", uriMemorija.writeEnable,uriMemorija.dataIn,uriMemorija.address,sURIMemoryWrite,counter,sCurrentState,data);
			//debug.simPrintf("uriMemorija.DATAout=%x, sUriWordCount=%u, sCounter=%u\n", uriMemorija.dataOut,sUriWordCount,counter);

			IF(sCurrentState.eq(States.HttpVersion))
			{
				//sUriRamAddress.next<==sUriRamAddress+1;
				//uriMemorija.address<==sUriRamAddress;

				//debug.simPrintf("ISCITAVANJE: uriMemorija.DATAout=%x, uriMemorija.address=%u, sUriRamAddress=%u, sCounter=%u\n", uriMemorija.dataOut,uriMemorija.address, sUriRamAddress, counter);
				//debug.simPrintf("sUriSimpleHash=%u\n",sUriSimpleHash);
			}
		}
	}

	@Override
	protected void outputFunction() { //executes in current tick?
		//input.slice(base, width)

		//output <== data # mod # eof # sof # socket;//data # mod # eof # sof # socket;//# mod # eof # sof # socket //constant.value(dfeUInt(10), 0) # counter # input; //input.cast(dfeUInt(77))
		DFEsmValue rrrr = socket # sof # eof # mod # data; //when word is received, MaxJ has reversed the order of the fields in the input stream. why?
		//output <== socket # sof # eof # mod # constant.value(dfeUInt(64),55);//rrrr;//.cast(dfeUInt(77));
		//sCurrentState.next<==States.Headers;

		//output <== rrrr;//.cast(dfeUInt(77));
		//debug.simPrintf("tick %u, data=%x\n", counter,data);
		IF(input.valid)
		{
			debug.simPrintf("tick %u, data: %x, mod: %x, eof: %x, sof: %x, socket: %x, input.valid=%x, output.stall=%x, input.stall=%x\n", counter,data, mod, eof,sof,socket,input.valid,output.stall, input.stall);
			debug.simPrintf("tick %u, input: %x\n", counter,input);
			debug.simPrintf("tick %u, rrrr: %x\n", counter,rrrr);
			debug.simPrintf("tick %u, sCounter=%u, SNumericCurrent=%u, byte1=%x\n", counter,counter,sCurrentState,byte1);
			debug.simPrintf("rrrr", "%u", 1);
		}
		//output.valid <== sCurrentState===States.endGETrequesta; //counter>100000;//input.valid; //input.valid & input.valid; // counter>2000

		output.valid<== false;
		output <== 0;


		IF(~sOutputStall) //output.stall
		{
			//IF((sRomDataOutValid===true)) //& (sCurrentROMAddress<sEndROMAddress)  // sMemoryRead
			//{//
			//				DFEsmValue data,mod,eof,sof;
			//
			//				data = constant.value(dfeUInt(64),16777215);; //00 00 00 00 00 FF FF FF = 3 x FF
			//				//socket=constant.value(dfeUInt(8),0);
			//				mod = constant.value(dfeUInt(3),0);
			//				eof=constant.value(dfeBool(),1);
			//				sof=constant.value(dfeBool(),1);
			//
			//				//output.valid<==false;
			//
			//				output<== 0;
			//
			//				//kad je addr=1 tada je na izlazu podatak dataOut(addr=0), jer je setovana latencija od 1 period
			//				//pa se sa output.valid dozvoljava output podatka na izlaz
			//				IF(sCurrentROMAddress.eq(sStartROMAddress+1)) //it doesnt work with sCurrentROMAddress===0 ????? //constant.value(dfeUInt(13),0))
			//				{
			//					data = romMemorija.dataOut;
			//					mod = constant.value(dfeUInt(3),0);
			//					eof = constant.value(dfeBool(),1);
			//					sof = constant.value(dfeBool(),1); //set SOF
			//					//socket=constant.value(dfeUInt(8),0);
			//					//output.valid<==true;
			//					//output<== sof # eof # mod # socket # data;
			//					output<== sof # eof # mod # socket # data;
			//
			//					debug.simPrintf("tick=%u, Petlja 1 - Adresa: %d, eof=%x,sof=%x, data=%x\n", counter, sCurrentROMAddress,eof,sof,data);
			//				}
			//
			//
			//				IF((sCurrentROMAddress>sStartROMAddress+1) & (sCurrentROMAddress<sEndROMAddress-1))
			//				{
			//					data = romMemorija.dataOut;
			//					mod = constant.value(dfeUInt(3),0);
			//					eof = constant.value(dfeBool(),1);
			//					sof = constant.value(dfeBool(),1);
			//					//socket=constant.value(dfeUInt(8),0);
			//					//output.valid<==true;
			//					//output<== sof # eof # mod # socket # data;
			//					output<== sof # eof # mod # socket # data;
			//
			//					debug.simPrintf("tick=%u, Izmedju - Adresa: %d, eof=%x,sof=%x, data=%x\n", counter, sCurrentROMAddress,eof,sof,data);
			//				}
			//
			//				IF(sCurrentROMAddress.eq(sEndROMAddress-1)) //it doesnt work with sCurrentROMAddress===0
			//				{
			//					data = romMemorija.dataOut;
			//					mod = constant.value(dfeUInt(3),0);
			//					eof = constant.value(dfeBool(),1);
			//					sof = constant.value(dfeBool(),1);
			//					//socket=constant.value(dfeUInt(8),0);
			//					//output.valid<==true;
			//					//output<== sof # eof # mod # socket # data;
			//					output<== sof # eof # mod # socket # data;
			//
			//					debug.simPrintf("tick=%u, Petlja 2 - Adresa: %d, eof=%x,sof=%x, data=%x\n", counter,sCurrentROMAddress,eof,sof,data);
			//				}
			//
			//				output.valid<== true;//~output.stall;
			//}

			//debug.simPrintf("tick=%u, output.valid=%x, output.stall=%x\n",counter, output.valid,output.stall);
		}

		//dataLengthBytes<==((sEndROMAddress-1)-(sStartROMAddress+1) + 1)*8;
		//dataLengthBytes.valid<==true;

		//LMem
		output.valid <== false;
		output<==0;
		dataFromMem.stall<==output.stall;

		//debug.simPrintf("tick=%u, output.valid=%x, output.stall=%x, dataFromMem.valid=%u\n",counter, output.valid,output.stall,dataFromMem.valid);

		IF(dataFromMem.valid & ~sAllBytesSentFlag)
		{
			//default
			DFEsmValue data,mod,eof,sof;
			data = dataFromMem;
			mod = constant.value(dfeUInt(3),0);
			eof = constant.value(dfeBool(),1);
			sof = constant.value(dfeBool(),1);

			output.valid <== dataFromMem.valid;
			output<== sof # eof # mod # socket # data;

			//if case
			IF(sFileLengthBytesCounter>=sFileLengthBytes)
			{
				output.valid <== dataFromMem.valid;

				//DFEsmValue data,mod,eof,sof;
				data = dataFromMem;

				DFEsmAssignableValue difference = assignable.value(dfeUInt(26));
				difference <== 8 - (sFileLengthBytesCounter-sFileLengthBytes);
				IF(difference===8) difference <== 0;

				mod = difference.cast(dfeUInt(3));//constant.value(dfeUInt(3),0);
				eof = constant.value(dfeBool(),1);
				sof = constant.value(dfeBool(),1);

				debug.simPrintf("Tick=%u, slanje: mod=%u, sFileLengthBytesCounter=%u, sFileLengthBytes=%u\n", counter, mod, sFileLengthBytesCounter, sFileLengthBytes);

				output<== sof # eof # mod # socket # data;

				//debug.simPrintf("\nKRAJ podataka za output, fromStateMachineDataSentFlag=%u, Tick=%u \n\n",fromStateMachineDataSentFlag,counter);
			}
		}

//		//signal for CPU: socket close
//		IF(sCloseSocketCycleFlag)
//		{
//
//			IF(sCloseSocketCycleCounter<17)
//			{
//				//posalji strim
//				//IF(~fromStateMachineDataSentFlag.stall)
//				{
//					fromStateMachineDataSentFlag.valid<==true;
//					fromStateMachineDataSentFlag<==socket;
//				}
//
//				debug.simPrintf("sCloseSocketCycleCounter=%u, Tick=%u\n",sCloseSocketCycleCounter,counter);
//			}
//		}

		//send data to FIFO URL buffer
//		storeUrlFifo.valid<==sHashZbirValid;
//		storeUrlFifo <== sHashZbirRegister.cast(dfeUInt(64+3+3)); //constant.value(dfeUInt(64+3+3), 200);

		fromStateMachineByteNumber.valid<==false;
		fromStateMachineByteNumber<==0;

		IF(sCloseSocketCycleFlag)
		{
			fromStateMachineByteNumber.valid<==true;
			fromStateMachineByteNumber<==sFileLengthBytes.cast(dfeUInt(128));
		}

//		IF(dataFromMem.valid)
//		{
//			debug.simPrintf("BYTELENGTH Tick=%u, fromStateMachineByteNumber.valid=%x, fromStateMachineByteNumber=%u\n",sCounter,fromStateMachineByteNumber.valid,fromStateMachineByteNumber);
//		}

		input.stall <== output.stall;

		String konstanta = String.format("%d", new BigInteger(1,"GE".getBytes())); //konvertuj string "GET " u hex oblik
		System.out.println("Konvertovani oblik " + konstanta);
		int width=32;
		DFEsmValue methodBits = constant.value(dfeUInt(width),new BigInteger(1,"GET ".getBytes()));

		memCmdOutput<==0;
		memCmdOutput.valid<==false;

		IF(~sMemCmdOutputStall) //
		{
			//komande za memorijski kontroler
			memCmdOutput <== memCmdReg;
			memCmdOutput.valid <== memCmdRegValid;

			IF (memCmdRegValid)
			{
				debug.simPrintf("tick=%u, memCmdOutput.stall=%u, Pushing out memory command***: %x\n", counter, memCmdOutput.stall, memCmdReg);
				//debug.simPrintf("Pushing DATA=%x\n", 11);
			}
		}

		checksumOutput.valid<==false;
		checksumOutput <== 0;

		IF(sHashIndexValid)
		{
			checksumOutput.valid<==true;
			checksumOutput <== sStoreURL.cast(dfeUInt(512));
		}

		IF(checksumResult.valid)
		{
			debug.simPrintf("tick=%u, rezultat parallelCRC: checksumResult=0x%x\n", counter, checksumResult);
		}

		//debug.simPrintf("Tick=%u, memCmdOutput=%x, memCmdOutput.valid=%x\n",sCounter,memCmdReg,memCmdRegValid);

//		IF(sLMemBytesSent===(sDataBurstLength-1)*192)
//		{
//			fromStateMachineDataSentFlag<==1;
//			fromStateMachineDataSentFlag.valid<==true;
//
//			debug.simPrintf("SVE poslato na output iz LMem: %x\n", sLMemBytesSent);
//		}

//		IF(sHashIndexValid===true)
//		{
//		  DFEsmAssignableValue ttt=assignable.value(dfeUInt(64));
//          debug.simPrintf("outputFunction() Postavljam romHashIndex.address na=%u, current=%u\n", sRomHashIndexAddress,counter);
//          ttt<==romHashIndex.dataOut;
//          debug.simPrintf("outputFunction() Vrednost romHashIndex.dataOut=%x, current=%u\n", romMemorija.dataOut,counter);
//		}

		//smOutput <== sCounter;

		//IF(sCurrentState===States.prijemURI)
		{
			//smOutput <== constant.value(dfeUInt(32), 55);
			//smOutput <== sCounter;
			//smOutput <== sHoldCounter;

			//smOutput <== sCounter;
			//smTest   <== sHoldCounter; //constant.value(dfeUInt(16), 47);
			//smBajt   <== byte1;
		}

		//smOutput <== byte1.cat(byte2).cast(dfeUInt(32));//sCounter;
		//smOutput <== byte1.cast(dfeUInt(32));//sCounter;

		IF(dataFromMem.valid)
		{
		  debug.simPrintf("Tick=%u, output=%x, output.valid=%u, dataFromMem=%x, sFileLengthBytesCounter=%u, sFileLengthBytes=%u\n", counter, output,output.valid, dataFromMem, sFileLengthBytesCounter, sFileLengthBytes);
		}
	}

	// private void doHashFunction(DFEsmAssignableValue result,
	// DFEsmAssignableValue[] inputs,
	// DFEsmAssignableValue startIndex,
	// DFEsmAssignableValue endIndex)
	// {
	// for(int i=0;i<inputs.length;i++)
	// {
	// IF((i>=startIndex) & (i<=endIndex))
	// {
	// //debug.simPrintf("Ovaj uslov=%d je ispunjen\n", i);
	// result<==result + inputs[i].cast(dfeUInt(15));
	// }
	// }
	// }

	private void makeWaitFlagCommand(DFEsmStateValue cmdReg, int streamIx,
			DFEsmValue flags, boolean untilSet) {
		SMUtils.assignField(cmdReg.next, cmdType, "address", flags);
		SMUtils.assignField(cmdReg.next, cmdType, "size", 0);
		SMUtils.assignField(
				cmdReg.next,
				cmdType,
				"inc",
				untilSet ? MemCommand.BlockUntilFlagsSet.getInstructionCode()
						: MemCommand.BlockUntilFlagsCleared
								.getInstructionCode());
		SMUtils.assignField(cmdReg.next, cmdType, "tag", 0);
		SMUtils.assignField(cmdReg.next, cmdType, "stream", 1 << streamIx);
	}

	private void makeSetFlagCommand(DFEsmStateValue cmdReg, int streamIx,
			DFEsmValue flag, boolean set) {
		SMUtils.assignField(cmdReg.next, cmdType, "address", flag);
		SMUtils.assignField(cmdReg.next, cmdType, "size", 0);
		SMUtils.assignField(cmdReg.next, cmdType, "inc",
				set ? MemCommand.SetFlags.getInstructionCode()
						: MemCommand.ClearFlags.getInstructionCode());
		SMUtils.assignField(cmdReg.next, cmdType, "tag", 0);
		SMUtils.assignField(cmdReg.next, cmdType, "stream", 1 << streamIx);
	}

	private void makeReadOrWriteCommand(DFEsmStateValue cmdReg,
			DFEsmValue address, int streamIx) {
		SMUtils.assignField(cmdReg.next, cmdType, "address", address);
		SMUtils.assignField(cmdReg.next, cmdType, "size", 1);
		SMUtils.assignField(cmdReg.next, cmdType, "inc", 1);
		SMUtils.assignField(cmdReg.next, cmdType, "tag", 0);
		SMUtils.assignField(cmdReg.next, cmdType, "stream", 1 << streamIx);
	}

	// private void makeControlCommand(DFEsmStateValue cmdReg, MemCommand cmd,
	// int flagIx) {
	// SMUtils.assignField(cmdReg.next, cmdType, "address", 1 << flagIx);
	// SMUtils.assignField(cmdReg.next, cmdType, "size", 0);
	// SMUtils.assignField(cmdReg.next, cmdType, "inc",
	// cmd.getInstructionCode());
	// SMUtils.assignField(cmdReg.next, cmdType, "tag", 0);
	// }

}
