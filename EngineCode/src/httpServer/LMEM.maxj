package httpServer;

import com.maxeler.maxblox.statemachine.SMUtils;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.LMemCommandStream;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.managers.DFEManager;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmAssignableValue;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateValue;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmValue;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushInput;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushOutput;
import com.maxeler.maxcompiler.v2.statemachine.manager.ManagerStateMachine;
import com.maxeler.maxcompiler.v2.statemachine.stdlib._State;

public class LMEM extends ManagerStateMachine {

	private enum MemCommand {
		NOP(0), ClearFlags(1), SetFlags(2), BlockUntilFlagsSet(4), BlockUntilFlagsCleared(5);

		private final int m_cmdCode;

		private MemCommand(int cmdCode) {
			m_cmdCode = cmdCode;
		}

		public int getInstructionCode() {
			return m_cmdCode;
		}
	}

	// LMem
	public static final String INPUT_MEM_DATA = "dataFromMem";
	public static final String OUTPUT_MEM_COMMAND = "memCmd";
	private final DFEStructType cmdType;

	private final DFEsmPushInput dataFromMem = io.pushInput(INPUT_MEM_DATA,	dfeUInt(64), 1); // burstSizeBits
	private final DFEsmPushInput dataFromHashIndex = io.pushInput("dataFromHashIndex",dfeUInt(64), 1); // burstSizeBits
	private final DFEsmPushOutput fromStateMachineByteNumber = io.pushOutput("fromStateMachineByteNumber", dfeUInt(128), 5);
	private final DFEsmPushOutput output = io.pushOutput("outputLMEM", dfeUInt(77), 1); // UDP TX stream format: 77 bits
	private final DFEsmPushOutput memCmdOutput;
	private final DFEsmStateValue memCmdReg;
	private final DFEsmStateValue memCmdRegValid;

	// private final int writeStreamID;
	private final int readStreamID;

	private final DFEsmStateValue counter = state.value(dfeUInt(20), 0); // 40
	private final DFEsmStateValue sMemoryRead = state.value(dfeBool(), false);
	private final DFEsmStateValue sMemCmdOutputStall = state.value(dfeBool(),false);
	private final DFEsmStateValue sStartROMAddress = state.value(dfeUInt(19), 0);
	private final DFEsmStateValue sDataBurstLength = state.value(dfeUInt(19), 0);
	private final DFEsmStateValue sFileLengthBytes = state.value(dfeUInt(26), 0);

	private final DFEsmStateValue sLMemBurstCounter = state.value(dfeUInt(19),0);
	private final DFEsmStateValue sBurstCounter = state.value(dfeUInt(19), 0);
	private final DFEsmStateValue sLMemBytesSent = state.value(dfeUInt(32), 0);
	private final DFEsmStateValue sFileLengthBytesCounter = state.value(dfeUInt(26), 8);
	private final DFEsmStateValue sAllBytesSentFlag = state.value(dfeBool(),false);
	private final DFEsmStateValue sFileLengthBytesCounterMini = state.value(dfeUInt(8), 8);
	private final DFEsmStateValue sCloseSocketCycleCounter = state.value(dfeUInt(5), 1);
	private final DFEsmStateValue sByteNumberFlag = state.value(dfeBool(),false);
	private final DFEsmStateValue sCloseSocketCycleFlag = state.value(dfeBool(), false);

	public LMEM(DFEManager owner, int readStreamID) {
		super(owner);

		// LMem
		cmdType = LMemCommandStream.getLMemCommandDFEStructType();

		// depth = depthBursts; //broj burstova,svaki od ovih burstova je
		// odredjenje velicine, obicno je burst=384 bajta
		// this.writeStreamID = writeStreamID;
		this.readStreamID = readStreamID;
		// this.basAddressBursts = basAddressBursts;

		memCmdReg = _State.value(state, dfeUInt(cmdType.getTotalBits()),"memCmdReg");
		memCmdRegValid = _State.value(state, dfeBool(), false, "memCmdRegValid");
		memCmdOutput = io.pushOutput(OUTPUT_MEM_COMMAND, dfeUInt(cmdType.getTotalBits()), 1);
}

@Override
protected void nextState() {

	counter.next <== counter + 1;

	memCmdRegValid.next <== false;
	sMemCmdOutputStall.next <== memCmdOutput.stall;

	IF(dataFromHashIndex.valid)
	{
		debug.simPrintf("LMEM: Value dataFromHashIndex=%x\n", dataFromHashIndex);

		DFEsmAssignableValue startAddressBurst=assignable.value(dfeUInt(19)); //startAddressBurst in LMem
		DFEsmAssignableValue fileLengthBursts=assignable.value(dfeUInt(19)); //length of a file as number of Bursts
		DFEsmAssignableValue fileLengthBytes=assignable.value(dfeUInt(26));  // 2^26 / 1024 /1024 = 64 MB, this is not integer number of bursts, last burst will not be fill to the end

		fileLengthBytes<==dataFromHashIndex.slice(0, 26); //romHashIndex.dataOut.slice(0, 26); //file length + ResponseHeaderlength(56 bytes)
		fileLengthBursts<==dataFromHashIndex.slice(26, 19); //romHashIndex.dataOut.slice(26, 19);
		startAddressBurst<==dataFromHashIndex.slice(45, 19); //romHashIndex.dataOut.slice(44, 19);

		debug.simPrintf("LMEM: startAddressBurst=%u, fileLengthBursts=%u, fileLengthBytes=%u\n",startAddressBurst,fileLengthBursts,fileLengthBytes);

		//LMem
		sStartROMAddress.next<==startAddressBurst;
		sDataBurstLength.next<==fileLengthBursts;
		sFileLengthBytes.next<==fileLengthBytes;

		sMemoryRead.next <== true;
	}

	IF((sMemoryRead===true))
	{
		IF((~memCmdOutput.stall)) //~memCmdOutput.stall
		{
			sLMemBurstCounter.next<==sLMemBurstCounter+1;
			//debug.simPrintf("Tick=%u, IZVRSAVAM read komandu\n",counter);
			makeReadOrWriteCommand(memCmdReg, //referenca ka objektu,adresa=base + x, streamID
					//constant.value(dfeUInt(32), 0), //basAddressBursts+ memWriteCommitPointer.cast(dfeUInt(32)
					(sStartROMAddress+sLMemBurstCounter).cast(dfeUInt(32)), //adresaRom ie. burst number
					readStreamID); //readStreamID

			memCmdRegValid.next <== true;

			IF(sLMemBurstCounter.eq(sDataBurstLength-1))
			{
				sMemoryRead.next<==false;
//				sRomAddressValid.next<==false;
//				sCurrentState.next<==States.start; //after memory was read, change current state;
//				sCurrentROMAddress.next<==0;
//				sRomDataOutValid.next<==0;

				sLMemBurstCounter.next<==0;
				debug.simPrintf("Last LMem read command sent, sLMemBurstCounter=%u\n", sLMemBurstCounter);
			}
		}
	}

	IF(dataFromMem.valid) //LMem
	{
		sLMemBytesSent.next<==sLMemBytesSent+8;
		sFileLengthBytesCounter.next<==sFileLengthBytesCounter+8;
		sFileLengthBytesCounterMini.next<==sFileLengthBytesCounterMini+8;

		//debug.simPrintf("Tick=%u, sLMemBurstCounter=%u, Podaci sa LMem dataFromLMem.valid=%x, dataFromLMem=%x,\n",counter,sLMemBurstCounter,dataFromMem.valid, dataFromMem)

		IF(sFileLengthBytesCounter>=sFileLengthBytes)
		{
			sAllBytesSentFlag.next<==true;
		}

		IF(~sByteNumberFlag)
		{
			sCloseSocketCycleFlag.next<==true;
			sByteNumberFlag.next<==true;
		}

		IF(sFileLengthBytesCounterMini===192)
		{
			sBurstCounter.next<==sBurstCounter+1;
			sFileLengthBytesCounterMini.next<==8;

			debug.simPrintf("Tick=%u, sBurstCounter=%u\n",counter,sBurstCounter);
		}
	}

	IF(sBurstCounter===sDataBurstLength)
	{
		sLMemBytesSent.next<==0;
		sAllBytesSentFlag.next<==false;
		sFileLengthBytesCounter.next<==8;
		sBurstCounter.next<==0;
		sDataBurstLength.next<==1;
		sByteNumberFlag.next<==false;

		debug.simPrintf("Tick=%u, sBurstCounter===sDataBurstLength\n",counter);
	}

	IF(sCloseSocketCycleFlag)
	{
		sCloseSocketCycleFlag.next<==false;
	}

	IF(~output.stall) //output.stall
	{

	}
}

@Override
protected void outputFunction() {

		//LMem
		output.valid <== false;
		output<==0;
		dataFromMem.stall<==output.stall;

		IF(dataFromMem.valid & ~sAllBytesSentFlag)
		{
			//default
			DFEsmValue data,mod,eof,sof, socket;
			data = dataFromMem;
			mod = constant.value(dfeUInt(3),0);
			eof = constant.value(dfeBool(),1);
			sof = constant.value(dfeBool(),1);

			socket = constant.value(dfeUInt(8),63); //input.slice(64, 8).cast(dfeUInt(8)); // bajt 11

			output.valid <== dataFromMem.valid;
			output<== sof # eof # mod # socket # data;

			//if case
			IF(sFileLengthBytesCounter>=sFileLengthBytes)
			{
				output.valid <== dataFromMem.valid;

				//DFEsmValue data,mod,eof,sof;
				data = dataFromMem;

				DFEsmAssignableValue difference = assignable.value(dfeUInt(26));
				difference <== 8 - (sFileLengthBytesCounter-sFileLengthBytes);
				IF(difference===8) difference <== 0;

				mod = difference.cast(dfeUInt(3));//constant.value(dfeUInt(3),0);
				eof = constant.value(dfeBool(),1);
				sof = constant.value(dfeBool(),1);

				debug.simPrintf("Tick=%u, slanje: mod=%u, sFileLengthBytesCounter=%u, sFileLengthBytes=%u\n", counter, mod, sFileLengthBytesCounter, sFileLengthBytes);

				output<== sof # eof # mod # socket # data;

				//debug.simPrintf("\nKRAJ podataka za output, fromStateMachineDataSentFlag=%u, Tick=%u \n\n",fromStateMachineDataSentFlag,counter);
			}
		}

		fromStateMachineByteNumber.valid<==false;
		fromStateMachineByteNumber<==0;

		IF(sCloseSocketCycleFlag)
		{
			fromStateMachineByteNumber.valid<==true;
			fromStateMachineByteNumber<==sFileLengthBytes.cast(dfeUInt(128));

			debug.simPrintf("LMEM: sFileLengthBytes=%x\n", sFileLengthBytes);
		}

		memCmdOutput<==0;
		memCmdOutput.valid<==false;

		IF(~sMemCmdOutputStall) //
		{
			//komande za memorijski kontroler
			memCmdOutput <== memCmdReg;
			memCmdOutput.valid <== memCmdRegValid;

			IF (memCmdRegValid)
			{
				debug.simPrintf("LMEM: tick=%u, memCmdOutput.stall=%u, Pushing out memory command***: %x\n", counter, memCmdOutput.stall, memCmdReg);
				//debug.simPrintf("Pushing DATA=%x\n", 11);
			}
		}

		IF(dataFromMem.valid)
		{
		  //debug.simPrintf("LMEM: Tick=%u, output=%x, output.valid=%u, dataFromMem=%x, sFileLengthBytesCounter=%u, sFileLengthBytes=%u\n", counter, output,output.valid, dataFromMem, sFileLengthBytesCounter, sFileLengthBytes);
		}
}

private void makeReadOrWriteCommand(DFEsmStateValue cmdReg,	DFEsmValue address, int streamIx) {
	SMUtils.assignField(cmdReg.next, cmdType, "address", address);
	SMUtils.assignField(cmdReg.next, cmdType, "size", 1);
	SMUtils.assignField(cmdReg.next, cmdType, "inc", 1);
	SMUtils.assignField(cmdReg.next, cmdType, "tag", 0);
	SMUtils.assignField(cmdReg.next, cmdType, "stream", 1 << streamIx);
}

//private void makeWaitFlagCommand(DFEsmStateValue cmdReg, int streamIx,
//		DFEsmValue flags, boolean untilSet) {
//	SMUtils.assignField(cmdReg.next, cmdType, "address", flags);
//	SMUtils.assignField(cmdReg.next, cmdType, "size", 0);
//	SMUtils.assignField(
//			cmdReg.next,
//			cmdType,
//			"inc",
//			untilSet ? MemCommand.BlockUntilFlagsSet.getInstructionCode()
//					: MemCommand.BlockUntilFlagsCleared
//							.getInstructionCode());
//	SMUtils.assignField(cmdReg.next, cmdType, "tag", 0);
//	SMUtils.assignField(cmdReg.next, cmdType, "stream", 1 << streamIx);
//}

//private void makeSetFlagCommand(DFEsmStateValue cmdReg, int streamIx,
//		DFEsmValue flag, boolean set) {
//	SMUtils.assignField(cmdReg.next, cmdType, "address", flag);
//	SMUtils.assignField(cmdReg.next, cmdType, "size", 0);
//	SMUtils.assignField(cmdReg.next, cmdType, "inc",
//			set ? MemCommand.SetFlags.getInstructionCode()
//					: MemCommand.ClearFlags.getInstructionCode());
//	SMUtils.assignField(cmdReg.next, cmdType, "tag", 0);
//	SMUtils.assignField(cmdReg.next, cmdType, "stream", 1 << streamIx);
//}

//private void doHashFunction(DFEsmAssignableValue result,
//DFEsmAssignableValue[] inputs,
//DFEsmAssignableValue startIndex,
//DFEsmAssignableValue endIndex)
//{
//for(int i=0;i<inputs.length;i++)
//{
//IF((i>=startIndex) & (i<=endIndex))
//{
////debug.simPrintf("Ovaj uslov=%d je ispunjen\n", i);
//result<==result + inputs[i].cast(dfeUInt(15));
//}
//}
//}

//debug.simPrintf("Tick=%u, memCmdOutput=%x, memCmdOutput.valid=%x\n",sCounter,memCmdReg,memCmdRegValid);

//IF(sLMemBytesSent===(sDataBurstLength-1)*192)
//{
//	fromStateMachineDataSentFlag<==1;
//	fromStateMachineDataSentFlag.valid<==true;
//
//	debug.simPrintf("SVE poslato na output iz LMem: %x\n", sLMemBytesSent);
//}


//private void makeControlCommand(DFEsmStateValue cmdReg, MemCommand cmd,
//int flagIx) {
//SMUtils.assignField(cmdReg.next, cmdType, "address", 1 << flagIx);
//SMUtils.assignField(cmdReg.next, cmdType, "size", 0);
//SMUtils.assignField(cmdReg.next, cmdType, "inc",
//cmd.getInstructionCode());
//SMUtils.assignField(cmdReg.next, cmdType, "tag", 0);
//}

//	IF((sMemoryRead===true)) //i hash je bio valid i stanje je bilo endGetRequest
//{
//	sCurrentROMAddress.next<==sCurrentROMAddress+1;
//	//romMemorija.address <== sCurrentROMAddress.cast(dfeUInt(MathUtils.bitsToAddress(Depth)));//constant.value(dfeUInt(13), 0);
//	//debug.simPrintf("tick=%u, IZVRSAVAM\n", counter);
//	//debug.simPrintf("tick %u, romMemorija.dataOut=%x, romMemorija.address=%u, sCurrentRomAddress=%u, sRomDataOutValid=%u\n", counter,romMemorija.dataOut,romMemorija.address,sCurrentROMAddress,sRomDataOutValid);
//
//	//sMemoryRead.next<==false;
//	//sRomAddressValid.next<==true;
//	sRomDataOutValid.next<==true;
//};

//		IF(sRomAddressValid===true)
//		{
//			sRomDataOutValid.next<==true;
//			sRomAddressValid.next<==false;
//		}

//IF(sCurrentROMAddress.eq(sEndROMAddress-1))
//{
////		sMemoryRead.next<==false;
////
////		sRomAddressValid.next<==false;
////		sCurrentState.next<==States.start; //after memory was read, change current state;
////		sCurrentROMAddress.next<==0;
////		sRomDataOutValid.next<==0;
////		debug.simPrintf("Iscitana poslednja adresa, adresa=%u\n", sCurrentROMAddress);
//}



}

