package stamp;

import java.io.File;
import java.io.FileReader;
import java.math.BigInteger;
import java.nio.ByteBuffer;

import com.maxeler.maxblox.statemachine.SMUtils;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.LMemCommandStream;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.managers.DFEManager;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmAssignableValue;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmMemAddress;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmSinglePortMappedROM;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmSinglePortRAM;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateEnum;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateValue;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmValue;
import com.maxeler.maxcompiler.v2.statemachine.Latency;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushInput;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushOutput;
import com.maxeler.maxcompiler.v2.statemachine.manager.ManagerStateMachine;
import com.maxeler.maxcompiler.v2.statemachine.stdlib.Mem.SinglePortRAMMode;
import com.maxeler.maxcompiler.v2.statemachine.stdlib._State;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

public class StampStateMachine extends ManagerStateMachine {

	enum Modes {
		COUNTING_UP, HOLD_COUNT, COUNTING_DOWN
	}
	enum Stanje {
		start, // 0
		URI,   		 // 1
		HttpVersion,   // 2
		Headers,    // 3
		CR,
		LF,
		BlankLine,
		endGETrequesta
		//receivingRequestLine, receivingURI, receivingHttpVersion,receivingBlankLine,
	}

	enum StanjeCRLF {
		prijemCR, // 0
		prijemLF,   		 // 1
		//receivingRequestLine, receivingURI, receivingHttpVersion,receivingBlankLine,
	}

	enum MemoryOutState {
	}

	private enum MemCommand {
		NOP                          (0),
		ClearFlags                   (1),
		SetFlags                     (2),
		BlockUntilFlagsSet           (4),
		BlockUntilFlagsCleared       (5);

		private final int m_cmdCode;
		private MemCommand(int cmdCode) {m_cmdCode = cmdCode;}
		public int getInstructionCode() {return m_cmdCode;}
	}


	//state
	private final DFEsmStateValue counter = state.value(dfeUInt(20), 0); //40
	private final DFEsmStateValue sDataPrevious = state.value(dfeUInt(64),0);
	private final DFEsmStateValue sDataValid = state.value(dfeBool(),0);
	private final DFEsmStateValue sRunOneMoreTick = state.value(dfeBool(),false);
	private final DFEsmStateValue sOuputEmpty = state.value(dfeBool(),true);
	private final DFEsmStateValue sMemoryRead = state.value(dfeBool(),false);
	private final DFEsmStateValue sCurrentROMAddress = state.value(dfeUInt(32),0);
	private final DFEsmStateValue sUriRamAddress = state.value(dfeUInt(7),0);
	private final DFEsmStateValue sPrev2Bytes = state.value(dfeUInt(16),0);
	private final DFEsmStateValue sPrev2BytesNiz[] = new DFEsmStateValue[8];
	private final DFEsmStateValue sURIMemoryWrite = state.value(dfeBool(),false);
	private final DFEsmStateValue sDataPreValue = state.value(dfeUInt(64),0);
	private final DFEsmStateValue sUriWordCount = state.value(dfeUInt(8),0);
	private final DFEsmStateValue sUriSimpleHash = state.value(dfeUInt(16),0);

	private final DFEsmStateValue sHashIndexValid = state.value(dfeBool(),false);
	private final DFEsmStateValue sRomHashIndexAddress = state.value(dfeUInt(15),0);
	private final DFEsmStateValue sHashIndexDataOutValid = state.value(dfeBool(),false);
	private final DFEsmStateValue sStartROMAddress = state.value(dfeUInt(19),0);
	private final DFEsmStateValue sEndROMAddress = state.value(dfeUInt(32),0);

	private final DFEsmStateValue sRomDataOutValid = state.value(dfeBool(),false);
	private final DFEsmStateValue sRomAddressValid = state.value(dfeBool(),false);
	private final DFEsmStateValue sCurrentRomAddressInitialized = state.value(dfeBool(),false);

	private final DFEsmStateValue sOutputByteCounter = state.value(dfeUInt(11),0);
	private final DFEsmStateValue sOutputStall = state.value(dfeBool(),false);
	private final DFEsmStateValue sLMemBurstCounter = state.value(dfeUInt(19),0);
	private final DFEsmStateValue sBurstCounter = state.value(dfeUInt(19),0);
	private final DFEsmStateValue sMemCmdOutputStall = state.value(dfeBool(),false);
	private final DFEsmStateValue sDataBurstLength = state.value(dfeUInt(19),0);
	private final DFEsmStateValue sLMemBytesSent = state.value(dfeUInt(32),0);
	private final DFEsmStateValue sFileLengthBytes = state.value(dfeUInt(26),0);
	private final DFEsmStateValue sFileLengthBytesCounter = state.value(dfeUInt(26),8);
	private final DFEsmStateValue sAllBytesSentFlag = state.value(dfeBool(),false);
	private final DFEsmStateValue sFileLengthBytesCounterMini = state.value(dfeUInt(8),8);
	private final DFEsmStateValue sCloseSocketCycleCounter= state.value(dfeUInt(5),1);
	private final DFEsmStateValue sCloseSocketCycleFlag= state.value(dfeBool(),false);
	private final DFEsmStateValue sByteNumberFlag= state.value(dfeBool(),false);


	// State - varijable stanja
	private final DFEsmStateValue sCounter;
	private final DFEsmStateValue sNumericCurrentState;
	private final DFEsmStateValue sHoldCounter;
	private final DFEsmStateEnum<Modes> sMode;
	private final DFEsmStateEnum<Stanje> sCurrentState;


	//int uLimit=24; //velicina HTMLarray (web page) + 1

	//LMem
	public static final String INPUT_MEM_DATA = "dataFromMem";
	public static final String OUTPUT_MEM_COMMAND = "memCmd";
	private final DFEStructType cmdType;
	private final DFEsmPushInput dataFromMem = io.pushInput(INPUT_MEM_DATA, dfeUInt(64), 1); //burstSizeBits
	private final DFEsmPushOutput memCmdOutput;
	private final DFEsmStateValue memCmdReg;
	private final DFEsmStateValue memCmdRegValid;
	//private final int writeStreamID;
	private final int readStreamID;
	//private final long basAddressBursts;
	//private final DFEsmStateValue dataFromMemReg;
	//private final DFEsmStateValue dataFromMemRegValid;



//
	//io
	private final DFEsmPushInput input = io.pushInput("tcp_to_sm", dfeUInt(77), 1); //UDP RX stream format: 748 bits
	private final DFEsmPushOutput output = io.pushOutput("stamped_tcp_frm_sm", dfeUInt(77), 1); // UDP TX stream format: 77 bits
	private final DFEsmPushOutput fromStateMachineByteNumber = io.pushOutput("fromStateMachineByteNumber", dfeUInt(128), 5);

	//private final DFEsmPullOutput output1 = io.pullOutput("stamped_udp_frm_sm", dfeUInt(77), 15);
	//private final DFEsmPushOutput output1 = io.pushOutput("stamped1", dfeUInt(77), 1);
	//

	//private final DFEsmInput gggg = io.scalarInput("ByteNumberSend", dfeUInt(16));
	//private final DFEsmPushOutput dataLengthBytes = io.pushOutput("dataLengthBytes", dfeUInt(32),1);

	//
	private final  DFEsmValue bajt1;
	private final  DFEsmValue bajt2;
	private final  DFEsmValue bajt3;
	private final  DFEsmValue bajt4;
	private final  DFEsmValue bajt5;
	private final  DFEsmValue bajt6;
	private final  DFEsmValue bajt7;
	private final  DFEsmValue bajt8;

//	private final  DFEsmStateValue sbajt1=state.value(dfeUInt(8),0);
//	private final  DFEsmStateValue sbajt2=state.value(dfeUInt(8),0);
//	private final  DFEsmStateValue sbajt3=state.value(dfeUInt(8),0);
//	private final  DFEsmStateValue sbajt4=state.value(dfeUInt(8),0);
//	private final  DFEsmStateValue sbajt5=state.value(dfeUInt(8),0);
//	private final  DFEsmStateValue sbajt6=state.value(dfeUInt(8),0);
//	private final  DFEsmStateValue sbajt7=state.value(dfeUInt(8),0);
//	private final  DFEsmStateValue sbajt8=state.value(dfeUInt(8),0);

	private final DFEsmStateValue  sInputValid = state.value(dfeBool(),false);

	private final  DFEsmStateValue sHashZbirRegister=state.value(dfeUInt(15),0);
	private final  DFEsmStateValue sHashZbirValid = state.value(dfeBool(),false);

	DFEsmMemAddress adresaRom;

	private final  DFEsmValue bajtovi[];
	//private final  DFEsmValue zbir=constant.value(dfeUInt(8), 0);

	//BRAM memories
	//private final  DFEsmSinglePortROM romMemorija;
	private final  DFEsmSinglePortMappedROM romMemorija;

	private final  DFEsmSinglePortMappedROM romHashIndex;
	//ALTERA ne podrzava READ_FIRST mode, mora da se stavi WRITE_FIRST
	//ISCA je sa Alterinim cipom
	private final  DFEsmSinglePortRAM uriMemorija=mem.ram(dfeUInt(64), 128, SinglePortRAMMode.WRITE_FIRST, Latency.ONE_CYCLE);

	private final DFEsmValue numSP = constant.value(dfeUInt(16),0); //number of SP characters (space)
	private final DFEsmValue blank[]=new DFEsmValue[8];

	private final  DFEsmValue data;
	private final  DFEsmValue mod;
	private final  DFEsmValue eof;
	private final  DFEsmValue sof;
	//private final  DFEsmValue checksum_bad;
	private final DFEsmValue socket;

	//private final ModularSMStateMachineLib mySMlib;

	private final  long Depth = (long) Math.pow(2.0, 15.0);

	public StampStateMachine(DFEManager owner, int readStreamID) {
		super(owner);

		//u konstruktoru se sa State varijabla radi sa '='
		//a u nextState() i OutputFunction() sa <== connect operatorom ???????????????????????

		//put code in the contructor,
		//java class fields defined above (dostupna svim metodama unutar klase)

		//TCP rx/tx format: fields extraction
		data = input.slice(0, 64).cast(dfeUInt(64));  // bajt
		socket = input.slice(64, 8).cast(dfeUInt(8)); // bajt 11
		mod = input.slice(72, 3).cast(dfeUInt(3));    // bajt 1
		eof = input.slice(75, 1).cast(dfeUInt(1));    // bajt 1
		sof = input.slice(76, 1).cast(dfeUInt(1));    // bajt 1

		//CounterChain chain = Control.count.makeCounterChain();
		//DFEVar burstCount = chain.addCounter(totalBursts,1);
		//DFEVar wordCount = chain.addCounter(wordsPerBurst,1);


		//UDP TX format stream:
		//  name	offset	width(bits)

		//  data 	0 		64
		//  mod 	64 		3
		//  eof 	67 		1
		//  sof 	68 		1
		//  socket  69 		8
		//	=====			77

		//bits ordering:  77|76|75|...|63|...|4|3|2|1|0


		//mHoldCount = 0;
		//DFEsmValueType counterType = dfeUInt(32);
		// I/O
		//smOutput = io.output("smOutput", dfeUInt(32));
		//smTest = io.output("smTest", dfeUInt(16));
		//smBajt = io.output("smBajt", dfeUInt(8));
		//smInput = io.input("smInput", dfeUInt(64));


		// State
		sMode = state.enumerated(Modes.class, Modes.COUNTING_UP);
		sCurrentState = state.enumerated(Stanje.class, Stanje.start);
		sCounter = state.value(dfeUInt(32), 0);
		sNumericCurrentState=state.value(dfeUInt(16),0);
		sHoldCounter = state.value(dfeUInt(16), 0);

		for(int i=0;i<sPrev2BytesNiz.length;i++)
		{
			sPrev2BytesNiz[i]=state.value(dfeUInt(8),0);
		}

		bajtovi=new DFEsmValue[8];
//		for(int i=0;i<8;i++) //
//		{
//			bajtovi[i]=constant.value(dfeUInt(8),0);
//
//		}

		bajtovi[0]=data.slice(0, 8).cast(dfeUInt(8)); //  #1
		bajtovi[1]=data.slice(8, 8).cast(dfeUInt(8)); //  #2
		bajtovi[2]=data.slice(16, 8).cast(dfeUInt(8)); // #3
		bajtovi[3]=data.slice(24, 8).cast(dfeUInt(8)); // #4
		bajtovi[4]=data.slice(32, 8).cast(dfeUInt(8)); // #5
		bajtovi[5]=data.slice(40, 8).cast(dfeUInt(8)); // #6
		bajtovi[6]=data.slice(48, 8).cast(dfeUInt(8)); // #7
		bajtovi[7]=data.slice(56, 8).cast(dfeUInt(8)); // #8

		//extract all 64 bits at once in parallel
		bajt1 = data.slice(0, 8).cast(dfeUInt(8)); //  #1
		bajt2 = data.slice(8, 8).cast(dfeUInt(8)); //  #2
		bajt3 = data.slice(16, 8).cast(dfeUInt(8)); // #3
		bajt4 = data.slice(24, 8).cast(dfeUInt(8)); // #4
		bajt5 = data.slice(32, 8).cast(dfeUInt(8)); // #5
		bajt6 = data.slice(40, 8).cast(dfeUInt(8)); // #6
		bajt7 = data.slice(48, 8).cast(dfeUInt(8)); // #7
		bajt8 = data.slice(56, 8).cast(dfeUInt(8)); // #8


		//statemachine library
		//mySMlib = new ModularSMStateMachineLib(this, bajt5);

//		for(int i=0;i<8;i++)
//		{
//			blank[i]=constant.value(dfeUInt(8),0);
//		}
//
		//memorija12
		String fileLocation="/home/nemanja/Desktop/htmlTest5Long.html";
		long HTMLarray[]=fillBRam(fileLocation, false, true);

		System.out.println("duzina htmlArray[]=" + HTMLarray.length);

		int p=0;
		for(long y: HTMLarray)
		{
		  //System.out.printf("adresa=%d, %x\n", p,y);
		  p++;
		}

		//romMemorija = mem.rom(dfeUInt(64),Latency.ONE_CYCLE, HTMLarray);
		romMemorija = mem.romMapped("romMapped",dfeUInt(64), 32768, Latency.ONE_CYCLE);

		//hashIndex
		System.out.println("Obradjujem hashIndex fajl");
		//String fileLocationHashIndex="/home/nemanja/Desktop/hashIndexFinalLongManja.html";//
		String fileLocationHashIndex="/home/nemanja/Desktop/hashIndexFinalLongLMem.html";//
		long hashIndex[]=fillBRam(fileLocationHashIndex,true, false);

		System.out.println("duzina hashIndex[]=" + hashIndex.length);

		p=0;
		for(long y: hashIndex)
		{
		  //System.out.printf("adresa hashIndex=%d, %x\n", p,y);
		  p++;
		}

		//int r=7/0;;

		//HashIndex =
		//romHashIndex = mem.rom(dfeUInt(64),Latency.ONE_CYCLE, hashIndex);
		romHashIndex = mem.romMapped("romHashIndex",dfeUInt(64), 32768, Latency.ONE_CYCLE);
		//romHashIndex = mem.romMapped("romHashIndex",dfeUInt(64), 32768, Latency.ONE_CYCLE);

//		ramMemorija.write(constant.var(0).cast(dfeUInt(10)), constant.var(124).cast(dfeUInt(64)) , constant.var(true));
//		DFEVar outputData = ramMemorija.read(constant.var(0).cast(dfeUInt(10)));
//
//		//Java kod se izvrsi, pa se onda onda builduje .max file koji se "spusta" na hardver
//		String text = "This text came from a FPGA";
//		int DATA_SIZE=text.length();
//		//byte niz[] = new byte[L]; //definise se niz duzine 1024 elementa kod koga su elementi 1 bajt = 8 bita
//		Bits niz[] = new Bits[DATA_SIZE];
//
//		//IF(data1===constant.var(dfeUInt(3),0)) //if ne radi u KERNEL-ima, samo u State Machine-i
//
//
//		for(int i=0;i<DATA_SIZE;i++)
//		{
//			niz[i]=new Bits(8,text.charAt(i)); //inicijalizacija ROM memorije sa inicijalnim vrednostima u vidu MaxJ Bits objekata
//		}
//		//Memory<DFEVar> romMemorija = mem.alloc(dfeUInt(8), DATA_SIZE);
//		//romMemorija.setContents(niz);
//
//		int BrojBitaZaAdresiranje = MathUtils.bitsToAddress(DATA_SIZE);
//		System.out.println("Potreban broj bita za adresiranje " + DATA_SIZE + " memorijskih lokacija je: " + BrojBitaZaAdresiranje);
//		//int y=7/0;

		//LMem
		cmdType = LMemCommandStream.getLMemCommandDFEStructType();

		//depth = depthBursts; //broj burstova,svaki od ovih burstova je odredjenje velicine, obicno je burst=384 bajta
		//this.writeStreamID = writeStreamID;
		this.readStreamID = readStreamID;
		//this.basAddressBursts = basAddressBursts;

		memCmdReg = _State.value(state, dfeUInt(cmdType.getTotalBits()), "memCmdReg");
		memCmdRegValid = _State.value(state, dfeBool(), false, "memCmdRegValid");
		memCmdOutput = io.pushOutput(OUTPUT_MEM_COMMAND, dfeUInt(cmdType.getTotalBits()), 1);

	}

	@Override
	protected void nextState() { //executes in next tick?

		//LMem section
		memCmdRegValid.next <== false;
		sMemCmdOutputStall.next<==memCmdOutput.stall;
//
		IF(dataFromMem.valid) //LMem
		{
			sLMemBytesSent.next<==sLMemBytesSent+8;
			sFileLengthBytesCounter.next<==sFileLengthBytesCounter+8;
			sFileLengthBytesCounterMini.next<==sFileLengthBytesCounterMini+8;

			//debug.simPrintf("Tick=%u, sLMemBurstCounter=%u, Podaci sa LMem dataFromLMem.valid=%x, dataFromLMem=%x,\n",counter,sLMemBurstCounter,dataFromMem.valid, dataFromMem)

			IF(sFileLengthBytesCounter>=sFileLengthBytes)
			{
				sAllBytesSentFlag.next<==true;
			}

//			//for disconnect
//			IF(sFileLengthBytesCounter>=sFileLengthBytes)
//			{
//				IF(~sAllBytesSentFlag)
//				{
//					sCloseSocketCycleFlag.next<==true;
//				}
//			}

			IF(~sByteNumberFlag)
			{
				sCloseSocketCycleFlag.next<==true;
				sByteNumberFlag.next<==true;
			}


			IF(sFileLengthBytesCounterMini===192)
			{
				sBurstCounter.next<==sBurstCounter+1;
				sFileLengthBytesCounterMini.next<==8;

				debug.simPrintf("Tick=%u, sBurstCounter=%u\n",counter,sBurstCounter);
			}
		}

		IF(sBurstCounter===sDataBurstLength)
		{
			sLMemBytesSent.next<==0;
			sAllBytesSentFlag.next<==false;
			sFileLengthBytesCounter.next<==8;
			sBurstCounter.next<==0;
			sDataBurstLength.next<==1;
			sByteNumberFlag.next<==false;

			debug.simPrintf("Tick=%u, sBurstCounter===sDataBurstLength\n",counter);
		}

//		IF(sCloseSocketCycleFlag)
//		{
//			sCloseSocketCycleCounter.next<==sCloseSocketCycleCounter+1;
//			IF(sCloseSocketCycleCounter===16)
//			{
//				sCloseSocketCycleFlag.next<==false;
//				sCloseSocketCycleCounter.next<==1;
//			}
//		}

		IF(sCloseSocketCycleFlag)
		{
			sCloseSocketCycleFlag.next<==false;
		}


		IF((sMemoryRead===true))
		{
			IF((~memCmdOutput.stall)) //~memCmdOutput.stall
			{
				sLMemBurstCounter.next<==sLMemBurstCounter+1;
				//debug.simPrintf("Tick=%u, IZVRSAVAM read komandu\n",counter);
				makeReadOrWriteCommand(memCmdReg, //referenca ka objektu,adresa=base + x, streamID
						//constant.value(dfeUInt(32), 0), //basAddressBursts+ memWriteCommitPointer.cast(dfeUInt(32)
						(sStartROMAddress+sLMemBurstCounter).cast(dfeUInt(32)), //adresaRom tj burst number
						readStreamID); //readStreamID

				memCmdRegValid.next <== true;

				IF(sLMemBurstCounter.eq(sDataBurstLength-1))
				{
					sMemoryRead.next<==false;
					sRomAddressValid.next<==false;
					sCurrentState.next<==Stanje.start; //after memory was read, change current state;
					sCurrentROMAddress.next<==0;
					sRomDataOutValid.next<==0;


					sLMemBurstCounter.next<==0;
					debug.simPrintf("Poslata poslednja LMem read komanda, sLMemBurstCounter=%u\n", sLMemBurstCounter);
				}
			}
		}


		sOutputStall.next<==output.stall;
		//IF(output.stall===true) sOutputStall.next<==true;

		IF(~output.stall) //output.stall
		{

			DFEsmAssignableValue hashZbir = assignable.value(dfeUInt(15));
			IF(sHashZbirValid===true)
			{
				hashZbir<==sHashZbirRegister;
				sHashZbirValid.next<==false;
				debug.simPrintf("Vrednost sHashZbirRegistra=%u\n", sHashZbirRegister);
			}
			ELSE
			{
				hashZbir<==0;
			}

			//		sbajt1.next <== data.slice(0, 8).cast(dfeUInt(8)); //  #1
			//		sbajt2.next <== data.slice(8, 8).cast(dfeUInt(8)); //  #2
			//		sbajt3.next <== data.slice(16, 8).cast(dfeUInt(8)); // #3
			//		sbajt4.next <== data.slice(24, 8).cast(dfeUInt(8)); // #4
			//		sbajt5.next <== data.slice(32, 8).cast(dfeUInt(8)); // #5
			//		sbajt6.next <== data.slice(40, 8).cast(dfeUInt(8)); // #6
			//		sbajt7.next <== data.slice(48, 8).cast(dfeUInt(8)); // #7
			//		sbajt8.next <== data.slice(56, 8).cast(dfeUInt(8)); // #8

			//TEST sa assignable variablama
			//		DFEsmValue test = constant.value(dfeUInt(8), 0);
			//		DFEsmAssignableValue testAssignableValue = assignable.value(dfeUInt(8)); //nova vrsta promenljive, izgleda da odgovara VHDL variablama
			//		testAssignableValue <== 0;
			//
			//		debug.simPrintf("pre IF: Vrednost test 1=%u, sCounter=%u\n", testAssignableValue,sCounter);
			//		IF(sCounter!==sCounter)
			//		{
			//			System.out.println("DDDDDDDD");
			//			test = constant.value(dfeUInt(8), 8);
			//			testAssignableValue <== 13;
			//			debug.simPrintf("u IF");
			//			//System.out.println("Vrednost DFEsmValue test=%u"+test);
			//
			//		}
			//
			//		testAssignableValue <== 9;
			//		debug.simPrintf("posle IF: Vrednost test=%u,,sCounter=%u\n", testAssignableValue,sCounter);

			sInputValid.next <== input.valid;

			//		IF(sURIMemoryWrite===true)
			//		{
			//			uriMemorija.writeEnable<==true;
			//		}
			//		ELSE {
			//			uriMemorija.writeEnable<==false;
			//		}
			//value assignments
			counter.next <== counter + 1;
			sDataPrevious.next <== data;
			sDataValid.next <== input.valid;

			//sPrev2BytesPoslednja.next <== bajt8 # bajt7; //2 bajta iz prethodnog ciklusa
			sPrev2Bytes.next <== bajt8 # bajt7;

			for(int i=0;i<sPrev2BytesNiz.length;i++)
			{
				sPrev2BytesNiz[i].next<==bajtovi[i];
			}

			//u ciklusu kada je stanje endGETrequest, znaci da je ulazni request prepoznan
			//to znaci da se odgovor moze poslati klijentu
			//zato u osmatranom trenutku podesi kontrolni signal
			//tako da se vec od sledeceg trenutka pocne sa iscitavanjem podataka
			//iz memorije i slanje ka klijentu
			IF(sCurrentState===Stanje.endGETrequesta)
			{
				sMemoryRead.next <==true; //od sledeceg trenutka ovaj kontrolni signal (inace varijabla stanja) ce imati vrednost true
				sCurrentState.next<==Stanje.start;
			}

			//DFEsmMemAddress adresaRom = romMemorija.address;

			IF((sMemoryRead===true) & (sCurrentRomAddressInitialized===true)) //i hash je bio valid i stanje je bilo endGetRequest
			{
				sCurrentROMAddress.next<==sCurrentROMAddress+1;
				romMemorija.address <== sCurrentROMAddress.cast(dfeUInt(MathUtils.bitsToAddress(Depth)));//constant.value(dfeUInt(13), 0);
				//debug.simPrintf("tick=%u, IZVRSAVAM\n", counter);
				//debug.simPrintf("tick %u, romMemorija.dataOut=%x, romMemorija.address=%u, sCurrentRomAddress=%u, sRomDataOutValid=%u\n", counter,romMemorija.dataOut,romMemorija.address,sCurrentROMAddress,sRomDataOutValid);

				//sMemoryRead.next<==false;
				//sRomAddressValid.next<==true;
				sRomDataOutValid.next<==true;
			};

			//		IF(sRomAddressValid===true)
			//		{
			//			sRomDataOutValid.next<==true;
			//			sRomAddressValid.next<==false;
			//		}

			IF(sCurrentROMAddress.eq(sEndROMAddress-1))
			{
//					sMemoryRead.next<==false;
//
//
//					sRomAddressValid.next<==false;
//					sCurrentState.next<==Stanje.start; //after memory was read, change current state;
//					sCurrentROMAddress.next<==0;
//					sRomDataOutValid.next<==0;
//					debug.simPrintf("Iscitana poslednja adresa, adresa=%u\n", sCurrentROMAddress);
			}

			IF(sHashIndexValid===true)
			{
				DFEsmAssignableValue ttt=assignable.value(dfeUInt(64));
				//sRomHashIndexAddress.next<==sRomHashIndexAddress+1;
				romHashIndex.address<==sRomHashIndexAddress;
				debug.simPrintf("Postavljam romHashIndex.address na=%u, current=%u\n", sRomHashIndexAddress,counter);
				sHashIndexValid.next<==false;
				ttt<==romHashIndex.dataOut;
				sHashIndexDataOutValid.next<==true;
				debug.simPrintf("Vrednost romHashIndex.dataOut=%x, current=%u\n", romHashIndex.dataOut,counter);

				// romHashIndex.dataOut;

				//          sMemoryRead.next<==false;
				//          sCurrentState.next<==Stanje.start; //after memory was read, change current state;
				//          sCurrentROMAddress.next<==0;
				//          debug.simPrintf("Iscitana poslednja adresa, adresa=%u", sCurrentROMAddress);
			}

			IF(sHashIndexDataOutValid===true) //
			{
				DFEsmAssignableValue startAddressBurst=assignable.value(dfeUInt(19)); //startAddressBurst in LMem
				DFEsmAssignableValue fileLengthBursts=assignable.value(dfeUInt(19)); //length of a file as number of Bursts
				DFEsmAssignableValue fileLengthBytes=assignable.value(dfeUInt(26));  // 2^26 / 1024 /1024 = 64 MB, ali ovo ipak nije celobrojan broj Burstova, poslednji burst nece biti zauzet do kraja

				fileLengthBytes<==romHashIndex.dataOut.slice(0, 26); //file length + ResponseHeaderlength(56 bytes)
				fileLengthBursts<==romHashIndex.dataOut.slice(26, 19);
				startAddressBurst<==romHashIndex.dataOut.slice(44, 19);

				debug.simPrintf("startAddressBurst=%u, fileLengthBursts=%u, fileLengthBytes=%u\n",startAddressBurst,fileLengthBursts,fileLengthBytes);

				//sHashIndexDataOutValid.next<==false;
				DFEsmAssignableValue startAddress=assignable.value(dfeUInt(32));
				DFEsmAssignableValue addressNumber=assignable.value(dfeUInt(32));

				addressNumber<==romHashIndex.dataOut.slice(0, 32);

				DFEsmValue addressByte1=addressNumber.slice(0, 8);
				DFEsmValue addressByte2=addressNumber.slice(8, 8);
				DFEsmValue addressByte3=addressNumber.slice(16, 8);
				DFEsmValue addressByte4=addressNumber.slice(24, 8);

				//addressNumber<==(addressByte1+addressByte2*10).cast(dfeUInt(32));
				addressNumber<==((addressByte1.cast(dfeUInt(32))+addressByte2.cast(dfeUInt(32))*10+addressByte3.cast(dfeUInt(32))*100+addressByte4.cast(dfeUInt(32))*1000)*4).cast(dfeUInt(32));
				//addressNumber<==271360;//12800;

				startAddress<==romHashIndex.dataOut.slice(32, 32);
				DFEsmValue startByte1=startAddress.slice(0, 8);
				DFEsmValue startByte2=startAddress.slice(8, 8);
				DFEsmValue startByte3=startAddress.slice(16, 8);
				DFEsmValue startByte4=startAddress.slice(24, 8);

				//startAddress<==(startByte1+startByte2*10).cast(dfeUInt(32));
				startAddress<==((startByte1.cast(dfeUInt(32))+startByte2.cast(dfeUInt(32))*10+startByte3.cast(dfeUInt(32))*100+startByte4.cast(dfeUInt(32))*1000)*4).cast(dfeUInt(32));
////
				//memorija na koju upucuje hashIndex
				sCurrentROMAddress.next<==startAddress;
				sCurrentRomAddressInitialized.next<==true;
				sEndROMAddress.next<==startAddress+addressNumber;

				//LMem
				sStartROMAddress.next<==startAddressBurst;
				sDataBurstLength.next<==fileLengthBursts;
				sFileLengthBytes.next<==fileLengthBytes;

				sHashIndexDataOutValid.next<==false;

				debug.simPrintf("addressByte1=%u, addressByte2=%u, addressByte3=%u, addressByte4=%u\n",addressByte1,addressByte2,addressByte3,addressByte4);
				debug.simPrintf("VALID romHashIndex, romHashIndex.dataOut=%x, startAddress=%u,addressNumber=%u, current=%u\n", romHashIndex.dataOut,startAddress,addressNumber,counter);
			}

			IF(sRomDataOutValid===true)
			{
				sOutputByteCounter.next<==sOutputByteCounter+1; //number of bytes sent to output port
				//debug.simPrintf("tick=%u, sRomDataOutValid=%u, sOutputByteCounter=%u\n",counter,sRomDataOutValid, sOutputByteCounter);
			}

			counter.next<==counter+1;

			//		IF(sEndOfReading)
			//		{
			//			sCurrentState.next<==Stanje.start;
			//		}

			//IF((sCurrentROMAddress))

			//case structures
			//IF(input.valid)
			//debug.simPrintf("Tick: %u, sRunOneMoreTick=%u, eof=%x **********\n", counter,sRunOneMoreTick,input.slice(67, 1).cast(dfeUInt(1)));
			//IF(counter>110000) counter.next<==0;

			//IF(input.valid) sRunOneMoreTick.next<==constant.value(dfeBool(),tr);

			//IF(input.valid) counter.next<==0;

			//HTTP request: opsti oblik
			// 1) request-line
			// 2) headers (0 or more)
			// 3) <blank line>
			// 4) body (only for a POST method)

			// URI requests:
			// / -> index.html
			// index.html -> index.html


			int width=32;
			//DFEsmValue headerMethod = smInput.slice(0, width).cast(dfeUInt(width)); // 1|2|3|4|5|6|7|8 => 8|7|6|5|4|3|2|1 posle slice funkcije
			// zasto menja raspored BAJTOVA (ne bitova)?

			//DFEVectorType<DFEsmValue> vector = new DFEVectorType<DFEsmValue>(dfeUInt(8), 8);
			//DFEVector<DFEVar> bajtovi = vector.newInstance(this);

			DFEsmValue methodGET = constant.value(dfeUInt(width),new BigInteger(1,"GET ".getBytes()));


			IF(input.valid)
			{
				//IF(sRunOneMoreTick===true) sRunOneMoreTick.next<==false;
				SWITCH(sCurrentState)
				{
					CASE(Stanje.start)
					{
						//DFEsmValue startIndex=constant.value(dfeUInt(3),7);
						//DFEsmValue startIndexFound=constant.value(false); //indicator

						///DFEsmValue endIndex=constant.value(dfeUInt(3),0);
						//DFEsmValue endIndexFound=constant.value(false);  //indicator

						//for(int i=0;i<8;i++) //loop unrolling, petlja se pretvara u 8 blokova koji se paralelno izvrsavaju
						{
							//debug.simPrintf("bajtovi[%d]=%x\n", i, bajtovi[i]);
							//blank[i]=bajtovi[i].eq(32)?constant.value(dfeUInt(8),2):constant.value(dfeUInt(8),0);
							//IF(bajtovi[i].eq(35)) //space
							{
								//numSP=numSP+1;


								//							IF(~startIndexFound)
								//							{
								//								startIndex=constant.value(dfeUInt(3),i);
								//								startIndexFound=constant.value(true);
								//
								//							}
								//
								//							IF((~endIndexFound) & startIndexFound)
								//							{
								//								IF(constant.value(dfeUInt(3),i)>startIndex)
								//								{
								//									endIndex=constant.value(dfeUInt(3),i);
								//									endIndexFound=constant.value(true);
								//								}
								//
								//							}

								//debug.simPrintf("bajt i=%u, Broj spaceova=%u\n", i, blank[i]);
								//sCurrentState.next<==Stanje.endGETrequesta;
								//debug.simPrintf("nextState: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
							}
							//ELSE {
							//blank[i]=constant.value(dfeUInt(3),0);
							//						}
						}


						//zbir=blank[0]+blank[1]+blank[2]+blank[3];//+blank[4]+blank[5]+blank[6]+blank[7]; //ukupan broj blank znakova, potreban kod extrakcije URI iz requesta
						//zbir=blank[3]+blank[5];

						//					IF((blank[0]+blank[1]+blank[2]+blank[3]+blank[4]+blank[5]+blank[6]+blank[7])>0)
						//					{
						//						debug.simPrintf("tralala\n");
						//					}

						//debug.simPrintf("INDEX: startIndex=%u, startIndexFound=%u, endIndex=%u, endIndexFound=%u\n", startIndex,startIndexFound,endIndex,endIndexFound);

						//if zbir>=2, krenuti sa pretragom od prvog indexa space
						//
						//kad detektujem prvi space, to znaci da sledeci bajt nakon njega pocinje startURI
						//sve dok ne detektujem drugi uzastopni space, URI je validan
						//kada se detektuje space to znaci da je bajt iza njega krajURI

						//debug.simPrintf("prijemRequestMethod: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						//DFEsmValue N4bajta = bajt1 # bajt2 # bajt3 # bajt4;
						DFEsmValue N4bajta = bajt1 # bajt2 # bajt3 # bajt4;
						DFEsmValue sum = constant.value(dfeUInt(16),0);
						DFEsmAssignableValue zbir = assignable.value(dfeUInt(4));
						zbir <== 0;


						IF (N4bajta === methodGET) { //uslov pod kojim se prelazi u sledece stanje

							IF(bajt4===' ') //space IF sa promenljivima ne RADI kako treba, prolazi cak i kad nije ispunjen uslov
							{
								//blank[5]=constant.value(dfeUInt(8),11); //BUG proveriti : dodela vrednosti VARIABLI (ne signalu) u IF petlji, bez obzira na vrednost uslova, a telo IF se normalno izvesava
								//debug.simPrintf("TRALALA\n");


								sURIMemoryWrite.next<==true;
								//kada se postavi na TRUE, drzi vrednost samo jedan ciklus???? resetuje se posle svakog ciklusa na FALSE
								uriMemorija.writeEnable<==true; //primljen PRVI space, oznacava da pocinje URI
								uriMemorija.dataIn<==data;
								uriMemorija.address<==sUriRamAddress;
								sUriRamAddress.next<==sUriRamAddress+1;

								//IF(bajt6===' ') sbajt1.next<==constant.value(dfeUInt(8),0);

								DFEsmAssignableValue startIndex=assignable.value(dfeUInt(3));
								startIndex<==7;

								DFEsmAssignableValue endIndex=assignable.value(dfeUInt(3));
								endIndex<==0;

								for(int i=0;i<8;i++)
								{
									IF(bajtovi[i]===' ') //paralelno racunanje zbira karaktera
									{
										IF(i<startIndex)
										{
											startIndex<==i;
										}

										IF((i>endIndex)) //(startIndex<endIndex)
										{
											endIndex<==i;
										}

										zbir<==zbir+1;
									}
								}

								IF(zbir>=2)
								{
									//ako je zbir>=2
									//to znaci da je URI poceo i zavrsio se
									//u tekucem ciklusu
									//pronadjen je i startIndex i endIndex
									//moze da se izracuna hash na bajtovima
									//izmedju startIndex i endIndex
									startIndex<==startIndex+1;
									endIndex<==endIndex-1;

									debug.simPrintf("ZBIR>=2, startIndex=%u, endIndex=%u\n",startIndex,endIndex);

								}
								ELSE
								{
									//ako je zbir=0 ili zbir=1,
									//to znaci da je URI (zbir=1) samo zapocet u tekucem ciklusu
									//onda nema potrebe da se vrednost smanjuje za 1
									//startIndex uvecaj za jedan kako bi dobio index bajta
									//od koga pocinje URI
									//kako se URI ne zavrsava u tekucoj word, onda endIndex
									//dodeli vrednost 7m jer jos nije kraj URIja

									//IF(startIndex===7) startIndex<==0;
									//IF(endIndex===0) endIndex<==7;

									startIndex<==startIndex+1;
									endIndex<==7;

								}


								debug.simPrintf("ZBIR zbir=%u, startIndex=%u, endIndex=%u\n",zbir,startIndex,endIndex);

								DFEsmAssignableValue bytes[]=new DFEsmAssignableValue[8];
								for(int u=0;u<8;u++)
								{
									bytes[u]=assignable.value(dfeUInt(8));
									bytes[u]<==bajtovi[u];
									IF(bajtovi[u]===' ')
									{
										bytes[u]<==0;
									}
								}

								for(int t=0;t<8;t++)
								{
									//debug.simPrintf("ZBIR blank[0]=%u, blank[3]=%u, blank[5]=%u, Broj spaceova=%u\n", blank[0],blank[3], blank[5],zbir);
									debug.simPrintf("ZBIR stanje Start bytes[%d]=%u\n",t,bytes[t]);
								}

								debug.simPrintf("Ulaz u doHash funkciju startIndex=%u, endIndex=%u\n",startIndex,endIndex);

								//							DFEsmAssignableValue g1=assignable.value(dfeUInt(3));
								//							g1<==4;
								doHashFunction(hashZbir, bytes,startIndex,endIndex);


								debug.simPrintf("Racunam hashZbir u stanju Start hashZbir=%u\n", hashZbir);


								//							IF(bajt5===' ')
								//							{
								//								//sum=constant.value(dfeUInt(16),11);
								//
								//							}

								//							IF(input.valid===true)
								//							{
								//								//sum=constant.value(dfeUInt(16),9);
								//								debug.simPrintf("GRESKA=%u\n",sum);
								//							}

								//input.stall<==true;

								//							SWITCH(bajt5){
								//								CASE('X')
								//								{
								//									sum=constant.value(dfeUInt(16),11);
								//								}
								//
								////								CASE('Y')
								////								{
								////									sum=constant.value(dfeUInt(16),12);
								////								}
								//							}
								//debug.simPrintf("SUM=%u\n",mySMlib.getCounter());

								sUriSimpleHash.next<==(bajt5+bajt6+bajt7+bajt8).cast(dfeUInt(16));

								sUriWordCount.next<==sUriWordCount+1; //nakon svakog upisavanja, uvecaj counter RECI za 1
							}
							//						ELSE
							//							{
							//								blank[5]=constant.value(dfeUInt(8),9);
							//							}

							//						for(int t=0;t<8;t++)
							//						{
							//							//debug.simPrintf("ZBIR blank[0]=%u, blank[3]=%u, blank[5]=%u, Broj spaceova=%u\n", blank[0],blank[3], blank[5],zbir);
							//							debug.simPrintf("ZBIR blank[%d]=%u\n",t,blank[t]);
							//						}

							IF(zbir>=2) //od indexa 4 do index 7, ako je bio
								//IF(bajt5===' ' | bajt6===' ' | bajt7===' ' | bajt8===' ') //in current word, also URI was received
							{
								//to znaci da je deo HTTP dela primljen vec u tekucem ciklusu
								//i taj deo treba procesirati tj obraditi i analizirati
								sCurrentState.next<==Stanje.HttpVersion;
								debug.simPrintf("nextState: prijemHttpVersion: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);

								//izracunati hash se moze smatrati validnim pocev od narednog ciklusa
								//sHashZbirFinal.next<==true;
							}
							ELSE {
								//1) postavi da se u sledecem ciklusu predje u URI stanje
								//2) u tekucem ciklusu izracunaj hash
								sCurrentState.next<==Stanje.URI;
								sHashZbirRegister.next<==hashZbir; //presi hashZbir u sledeci ciklus, jer DFEsmAssignableValue ne moze izmedju ciklusa
								sHashZbirValid.next<==true;


								debug.simPrintf("nextState: prijemURI: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
							}
						}
					}
					CASE(Stanje.URI)
					{
						DFEsmAssignableValue zbirStanjeURI = assignable.value(dfeUInt(4));
						zbirStanjeURI <== 0;
						DFEsmAssignableValue startIndex=assignable.value(dfeUInt(3));
						startIndex<==0;
						DFEsmAssignableValue endIndex=assignable.value(dfeUInt(3));
						endIndex<==0;

						for(int i=0;i<8;i++)
						{
							IF(bajtovi[i]===' ') //paralelno racunanje zbira karaktera
							{
								//							IF(i<startIndex) //posto se ocekuje kraj URIja treba ti samo endIndex, startIndex=0
								//							{
								//								startIndex<==i;
								//							}

								IF((i>endIndex)) //(startIndex<endIndex)
								{
									endIndex<==i;
								}

								zbirStanjeURI<==zbirStanjeURI+1;
							}
						}

						IF(zbirStanjeURI>=2)
						{

							startIndex<==startIndex+1;
							endIndex<==endIndex-1;

							debug.simPrintf("ZBIR>=2, startIndex=%u, endIndex=%u\n",startIndex,endIndex);

						}
						ELSE IF(zbirStanjeURI===1)
						{
							//IF(startIndex===7) startIndex<==0;
							//IF(endIndex===0) endIndex<==7;

							//startIndex<==startIndex+1;
							IF(endIndex!==0) endIndex<==endIndex-1;
						}
						ELSE IF(zbirStanjeURI===0)
						{
							startIndex<==0;
							endIndex<==7;
						}

						DFEsmAssignableValue bytes[]=new DFEsmAssignableValue[8];
						for(int u=0;u<8;u++)
						{
							bytes[u]=assignable.value(dfeUInt(8));
							bytes[u]<==bajtovi[u];
							IF(bajtovi[u]===' ')
							{
								bytes[u]<==0;
							}
						}

						//1) izracunaj hash tekuce word (64bits) and accumulate the result
						//2)

						for(int t=0;t<8;t++)
						{
							//debug.simPrintf("ZBIR blank[0]=%u, blank[3]=%u, blank[5]=%u, Broj spaceova=%u\n", blank[0],blank[3], blank[5],zbir);
							debug.simPrintf("ZBIR stanje URI bytes[%d]=%u\n",t,bytes[t]);
						}

						debug.simPrintf("STANJE URI: Ulaz u doHash funkciju startIndex=%u, endIndex=%u\n",startIndex,endIndex);
						doHashFunction(hashZbir,bytes,startIndex,endIndex);

						debug.simPrintf("Racunam hashZbir u stanju URI hashZbir=%u\n", hashZbir);

						//ako je sistem u stanju prijema URIja onda, kad detektujes blank predji u stanje prijema Http verzije
						//url koji se prosledjuju requestom: da li je case-sensitive ili ne??? pogledati rfc
						//debug.simPrintf("prijemURI: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						IF (bajt1===' ' | bajt2===' ' | bajt3===' ' | bajt4===' ' | bajt5===' ' | bajt6===' ' | bajt7===' ' | bajt8===' ')
						{
							//ako je detektovan space => oznacava kraj URI, dalje sleduje HTTP deo
							//dva slucaja:
							// 1) HTTP deo pocinje i zavrsava se u trenutnoj WORD => tada odmah mozes da predjes u stanje koje ide nakon HTTP
							// 2) HTTP deo samo pocinje => tada si od sledece ciklusa u stanju HTTP

							//URI sigurno ne sadrzi blankove (blank se zamenjuje sa %20 ili nekim safe karakterom)
							//pa je blank iza URIja (metoda+blank je ispitano u prijemMetodi
							sCurrentState.next<==Stanje.HttpVersion;
							//sUriRamAddress.next<==0;

							sHashZbirRegister.next<==hashZbir;
							sHashIndexValid.next<==true; //posto je detektovan kraj URI, postavi valid flag na true
							sRomHashIndexAddress.next<==hashZbir;


							//uriMemorija.writeEnable<==true; //ako je stanje URI, onda to znaci da su primljene bar 2 words u razlicitim ciklusima
							//ako je detektovan SPACE (hex 20) onda to znaci da se u ovoj reci zavrsava URI, stigao zavrsni SPACE
							//iskljuci upisivanje u memoriju

							debug.simPrintf("nextState: prijemHttpVersion: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						}
						ELSE{
							//sve dok si u stanju URI, upisuj trenutni podatak u memoriju, povecavaj adresu
							//drugi deo kod definisace prelazak u sledece stanje
							sUriRamAddress.next<==sUriRamAddress+1;

							sCurrentState.next<==Stanje.URI;
							sHashZbirRegister.next<==hashZbir; //presi hashZbir u sledeci ciklus, jer DFEsmAssignableValue ne moze izmedju ciklusa
							sHashZbirValid.next<==true;

						}

						//ako izlazis iz stanja URI onda iskljuci ispisivanje u URI memoriju
						uriMemorija.writeEnable<==true; //


						//ako je bilo koji ulazni bajt == ' ' tj spaceu
						//onda on ne bi trebalo da bude upisan u URI memoriju
						// i za njega ne bi trebalo da se racuna hash
						//poslednji pristigli podatak do tog spacea,
						//se smatra validnim delom URIja
						//
						//sUriSimpleHash.next<==(bajt1+bajt2+bajt3+bajt4+bajt5+bajt6+bajt7+bajt8).cast(dfeUInt(16));

						//uriMemorija.dataIn<==data;
						//uriMemorija.address<==sUriRamAddress;
						//sUriWordCount.next<==sUriWordCount+1;

					}
					CASE(Stanje.HttpVersion)
					{
						//sCurrentState.next<==Stanje.prijemRequestMethod;

						//debug.simPrintf("prijemHttpVersion: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);

						//kraj HTTP verzije se detektuje sa CRLF sekvencom, tako je prema RFC standardu
						//CR+LF, '\r\n', 0x0D0A (CR=13dec LF=10d)
						//					IF (bajt1===13 | bajt2===13 | bajt3===13 | bajt4===13 | bajt5===13 | bajt6===13 | bajt7===13 | bajt8===13)
						//					{
						//						//ako je detektovan space ' '
						//						//predji u stanje prijema HTTP
						//						//URI sigurno ne sadrzi blankove (blank se zamenjuje sa %20 ili nekim safe karakterom)
						//						//pa je blank iza URIja (metoda+blank je ispitano u prijemMetodi)
						//						sCurrentState.next<==Stanje.prijemLF;
						//						sHoldCounter.next<==8;
						//
						//						debug.simPrintf("nextState: prijemLF: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						//
						//						//sHoldCounter.next<==3;
						//
						//					}

						//					for(int i=0;i<7;i++) //loop unrolling, petlja se pretvara u 8 blokova koji se paralelno izvrsavaju
						//					{
						//						IF(bajtovi[i]===13 & bajtovi[i+1]===10)
						//						{
						//							sCurrentState.next<==Stanje.BlankLine;
						//							//pronadjen===true;
						//							//debug.simPrintf("nextState: prijemBlankLine: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						//						}
						//					}

						//bezuslovna detekcija dva uzastopna CRLF karaktera
						//1) 2 uzastopna u current WORD
						//2)  uzastopni iz predthodne i tekuce WORD

						//oznacava kraj Requesta, koristiti samo kad se zeli detektovati kraj requesta bez prolaska kroz ostala stanja
						debug.simPrintf("U HTTP stanju: bajt1=%x, bajt2=%x, sPrev2Bytes=%x\n",bajt1,bajt2,sPrev2Bytes);
						IF(input.valid)
						{
							//2 bajta iz prethodnog ciklusa da li su jednaka sa pocetnim bajtovima
							IF (bajt1===13 & bajt2===10)
								IF (sPrev2Bytes === (bajt2 # bajt1))
								{
									sCurrentState.next<==Stanje.endGETrequesta;
									debug.simPrintf("nextState 1: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}


							//0p,1p sa 0,1 - p: prethodno
							//5p,6p,7p sa 0
							//7p sa 0,1,2

							//0p,1p sa 0,1 - p: prethodno
							IF (bajt1===13 & bajt2===10) //ako su u prethnodnom ciklusu stigla samo dva bajta i to bas CRLF
								IF ((sPrev2BytesNiz[1] # sPrev2BytesNiz[0]) === (bajt2 # bajt1))
								{
									sCurrentState.next<==Stanje.endGETrequesta;
									debug.simPrintf("nextState 7: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}


							//5p,6p,7p sa 0
							IF ((sPrev2BytesNiz[5]===13) & (sPrev2BytesNiz[6] === 10))
								IF ((sPrev2BytesNiz[7] === 13) & (bajt1===10))
								{
									sCurrentState.next<==Stanje.endGETrequesta;
									debug.simPrintf("nextState 8: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							//7p sa 0,1,2
							IF ((sPrev2BytesNiz[7]===13) & (bajt1 === 10))
								IF ((bajt2 === 13) & (bajt3===10))
								{
									sCurrentState.next<==Stanje.endGETrequesta;
									debug.simPrintf("nextState 9: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							//u trenutnoj word da li su prisutne 2 susedna CRLF
							IF (bajt1===13 & bajt2===10)
								IF ((bajt1 # bajt2) === (bajt3 # bajt4))
								{
									sCurrentState.next<==Stanje.endGETrequesta;
									debug.simPrintf("nextState 2: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							IF (bajt2===13 & bajt3===10)
								IF ((bajt2 # bajt3) === (bajt4 # bajt5))
								{
									sCurrentState.next<==Stanje.endGETrequesta;
									debug.simPrintf("nextState 3: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							IF (bajt3===13 & bajt4===10)
								IF ((bajt3 # bajt4) === (bajt5 # bajt6))
								{
									sCurrentState.next<==Stanje.endGETrequesta;
									debug.simPrintf("nextState 4: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							IF (bajt4===13 & bajt5===10)
								IF ((bajt4 # bajt5) === (bajt6 # bajt7))
								{
									sCurrentState.next<==Stanje.endGETrequesta;
									debug.simPrintf("nextState 5: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}

							IF (bajt5===13 & bajt6===10)
								IF ((bajt5 # bajt6) === (bajt7 # bajt8))
								{
									sCurrentState.next<==Stanje.endGETrequesta;
									debug.simPrintf("nextState 6: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}
						}

					}
					CASE(Stanje.LF) //obrisati prijemCR
					{
						//sCurrentState.next<==Stanje.prijemRequestMethod;
						//debug.simPrintf("prijemLF: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);

						//kraj HTTP verzije se detektuje sa CRLF sekvencom, tako je prema RFC standardu
						//CR+LF, '\r\n', 0x0D0A (CR=13dec LF=10d)
						//IF (bajt1===10 | bajt2===10 | bajt3===10 | bajt4===10 | bajt5===10 | bajt6===10 | bajt7===10 | bajt8===10)
						{
							//ako je detektovan space ' '
							//predji u stanje prijema HTTP
							//URI sigurno ne sadrzi blankove (blank se zamenjuje sa %20 ili nekim safe karakterom)
							//pa je blank iza URIja (metoda+blank je ispitano u prijemMetodi

							for(int i=0;i<7;i++) //loop unrolling, petlja se pretvara u 8 blokova koji se paralelno izvrsavaju
							{
								IF(bajtovi[i]===13 & bajtovi[i+1]===10)
								{
									//sCurrentState.next<==Stanje.endGETrequesta;
									//debug.simPrintf("nextState: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
								}
							}

							sCurrentState.next<==Stanje.BlankLine;

							//debug.simPrintf("nextState: prijemBlankLine: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
						}
					}
					CASE(Stanje.BlankLine) //blank linija je samo CRLF, jedan do drugog
					{

						//za jednostavan slucaj GET requesta HTTP-a, treba ignorisati sve headere

						//debug.simPrintf("prijemBlankLine: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);

						//				IF (bajt1===10 | bajt2===10 | bajt3===10 | bajt4===10 | bajt5===10 | bajt6===10 | bajt7===10 | bajt8===10)
						//				{
						//					//ako je detektovan space ' '
						//					//predji u stanje prijema HTTP
						//					//URI sigurno ne sadrzi blankove (blank se zamenjuje sa %20 ili nekim safe karakterom)
						//					//pa je blank iza URIja (metoda+blank je ispitano u prijemMetodi
						//					sCurrentState.next<==Stanje.prijemBlankLine;
						//				}

						for(int i=0;i<7;i++) //loop unrolling, petlja se pretvara u 8 blokova koji se paralelno izvrsavaju
						{
							IF(bajtovi[i]===13 & bajtovi[i+1]===10)
							{
								//sCurrentState.next<==Stanje.endGETrequesta;
								//debug.simPrintf("nextState: krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
							}
						}
					}

					CASE(Stanje.endGETrequesta)
					{
						//ako je detektovan kraj HTTP requesta onda mozes da predjes na dohvatanje podataka i vracanja HTTP responsa
						//simple case: vrati odredjenu vrednost promenljive nazad


						//debug.simPrintf("krajGETrequesta: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
					}
				} //end switch
			}

			SWITCH (sCurrentState) {
				CASE (Stanje.start) {
					//debug.simPrintf("R: prijemStart: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (Stanje.URI) {
					//debug.simPrintf("R: prijemURI: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (Stanje.HttpVersion) {
					//debug.simPrintf("R: prijemHttpVersion: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (Stanje.CR) {
					//debug.simPrintf("R: prijemCR: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (Stanje.LF) {
					//debug.simPrintf("R: prijemLF: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (Stanje.BlankLine) {
					//debug.simPrintf("R: prijemBlankLine: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
				}

				CASE (Stanje.endGETrequesta) {
					//debug.simPrintf("R: krajGETrequesta: sCounter=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);

					debug.simPrintf("tick %u, romMemorija.dataOut=%x, romMemorija.address=%u, sCurrentRomAddress=%u, sRomDataOutValid=%u\n", counter,romMemorija.dataOut,romMemorija.address,sCurrentROMAddress,sRomDataOutValid);
				}

				OTHERWISE {

				}
			}

			//debug.simPrintf("uriMemorija.writeEnable=%u, uriMemorija.dataIn=%x, uriMemorija.address=%u, sURIMEmoryWrite=%u, sCounter=%u, sNumericCurrent=%u, data=%x\n", uriMemorija.writeEnable,uriMemorija.dataIn,uriMemorija.address,sURIMemoryWrite,counter,sCurrentState,data);
			//debug.simPrintf("uriMemorija.DATAout=%x, sUriWordCount=%u, sCounter=%u\n", uriMemorija.dataOut,sUriWordCount,counter);

			IF(sCurrentState.eq(Stanje.HttpVersion))
			{
				//sUriRamAddress.next<==sUriRamAddress+1;
				//uriMemorija.address<==sUriRamAddress;

				//debug.simPrintf("ISCITAVANJE: uriMemorija.DATAout=%x, uriMemorija.address=%u, sUriRamAddress=%u, sCounter=%u\n", uriMemorija.dataOut,uriMemorija.address, sUriRamAddress, counter);
				//debug.simPrintf("sUriSimpleHash=%u\n",sUriSimpleHash);
			}


			//		SWITCH(sMode) {
			//			CASE(Modes.COUNTING_UP) {
			//				IF(sCounter === iMax) {
			//					sMode.next <== Modes.HOLD_COUNT;
			//				} ELSE {
			//					/* We need to check that we are not larger than
			//					 * m_max, as it might have changed
			//					 */
			//					IF(sCounter > iMax) {
			//						sCounter.next <== iMax;
			//						sMode.next <== Modes.HOLD_COUNT;
			//					} ELSE {
			//						sCounter.next <== sCounter + 1;
			//					}
			//				}
			//			}
			//			CASE(Modes.COUNTING_DOWN) {
			//				IF(sCounter === 0) {
			//					sCounter.next <== sCounter + 1;
			//					sMode.next <== Modes.COUNTING_UP;
			//				} ELSE {
			//					sCounter.next <== sCounter - 1;
			//				}
			//			}
			//			OTHERWISE {
			//				IF (sHoldCounter === mHoldCount)
			//				{
			//					sHoldCounter.next <== 0;
			//					sMode.next <== Modes.COUNTING_DOWN;
			//				}
			//				ELSE {
			//					sHoldCounter.next <== sHoldCounter+1;
			//				}
			///			}
			//		}
		}
	}

	@Override
	protected void outputFunction() { //executes in current tick?
		//input.slice(base, width)

		//output <== data # mod # eof # sof # socket;//data # mod # eof # sof # socket;//# mod # eof # sof # socket //constant.value(dfeUInt(10), 0) # counter # input; //input.cast(dfeUInt(77))
		DFEsmValue rrrr = socket # sof # eof # mod # data; //when word is received, MaxJ has reversed the order of the fields in the input stream. why?
		//output <== socket # sof # eof # mod # constant.value(dfeUInt(64),55);//rrrr;//.cast(dfeUInt(77));
		//sCurrentState.next<==Stanje.Headers;

//		DFEsmAssignableValue a = assignable.value(dfeUInt(16));
//		a<==7;
//		DFEsmAssignableValue b = assignable.value(dfeUInt(16));
//		b<==3;
//
//		DFEsmAssignableValue test = assignable.value(dfeUInt(16));
//
//
//
//
//		test<==a/b;

//		IF(sCurrentState===Stanje.endGETrequesta)
//		{
//			DFEsmValue data,mod,eof,sof;
//			//socket;
//			data = constant.value(dfeUInt(64),255); // bajt 1
//			mod = constant.value(dfeUInt(3),0); // bajt 1
//			eof = constant.value(dfeBool(),1);//cast(dfeUInt(1)); // bajt 1
//			sof = constant.value(dfeBool(),1); // bajt 1
//
//			//socket = input.slice(70, 8).cast(dfeUInt(8)); // bajt 1
//			data = romMemorija.dataOut.cast(dfeUInt(64));
//			//output <== socket # sof # eof # mod # data;//rrrr;//.cast(dfeUInt(77));
//
//		}

		//output <== rrrr;//.cast(dfeUInt(77));
		//debug.simPrintf("tick %u, data=%x\n", counter,data);
		IF(input.valid)
		{
			debug.simPrintf("tick %u, data: %x, mod: %x, eof: %x, sof: %x, socket: %x, input.valid=%x, output.stall=%x, input.stall=%x\n", counter,data, mod, eof,sof,socket,input.valid,output.stall, input.stall);
			debug.simPrintf("tick %u, input: %x\n", counter,input);
			debug.simPrintf("tick %u, rrrr: %x\n", counter,rrrr);
			debug.simPrintf("tick %u, sCounter=%u, SNumericCurrent=%u, bajt1=%x\n", counter,counter,sCurrentState,bajt1);
			debug.simPrintf("rrrr", "%u", 1);
		}
		//output.valid <== sCurrentState===Stanje.endGETrequesta; //counter>100000;//input.valid; //input.valid & input.valid; // counter>2000

		output.valid<== false;
		output <== 0;

		//SWITCH(sMemoryRead) /

		IF(~sOutputStall) //output.stall
		{
			//IF((sRomDataOutValid===true)) //& (sCurrentROMAddress<sEndROMAddress)  // sMemoryRead
			//{//
			//				DFEsmValue data,mod,eof,sof;
			//
			//				data = constant.value(dfeUInt(64),16777215);; //00 00 00 00 00 FF FF FF = 3 x FF
			//				//socket=constant.value(dfeUInt(8),0);
			//				mod = constant.value(dfeUInt(3),0);
			//				eof=constant.value(dfeBool(),1);
			//				sof=constant.value(dfeBool(),1);
			//
			//				//output.valid<==false;
			//
			//				output<== 0;
			//
			//				//kad je addr=1 tada je na izlazu podatak dataOut(addr=0), jer je setovana latencija od 1 period
			//				//pa se sa output.valid dozvoljava output podatka na izlaz
			//				IF(sCurrentROMAddress.eq(sStartROMAddress+1)) //it doesnt work with sCurrentROMAddress===0 ????? //constant.value(dfeUInt(13),0))
			//				{
			//					data = romMemorija.dataOut;
			//					mod = constant.value(dfeUInt(3),0);
			//					eof = constant.value(dfeBool(),1);
			//					sof = constant.value(dfeBool(),1); //set SOF
			//					//socket=constant.value(dfeUInt(8),0);
			//					//output.valid<==true;
			//					//output<== sof # eof # mod # socket # data;
			//					output<== sof # eof # mod # socket # data;
			//
			//					debug.simPrintf("tick=%u, Petlja 1 - Adresa: %d, eof=%x,sof=%x, data=%x\n", counter, sCurrentROMAddress,eof,sof,data);
			//				}
			//
			//
			//				IF((sCurrentROMAddress>sStartROMAddress+1) & (sCurrentROMAddress<sEndROMAddress-1))
			//				{
			//					data = romMemorija.dataOut;
			//					mod = constant.value(dfeUInt(3),0);
			//					eof = constant.value(dfeBool(),1);
			//					sof = constant.value(dfeBool(),1);
			//					//socket=constant.value(dfeUInt(8),0);
			//					//output.valid<==true;
			//					//output<== sof # eof # mod # socket # data;
			//					output<== sof # eof # mod # socket # data;
			//
			//					debug.simPrintf("tick=%u, Izmedju - Adresa: %d, eof=%x,sof=%x, data=%x\n", counter, sCurrentROMAddress,eof,sof,data);
			//				}
			//
			//				IF(sCurrentROMAddress.eq(sEndROMAddress-1)) //it doesnt work with sCurrentROMAddress===0
			//				{
			//					data = romMemorija.dataOut;
			//					mod = constant.value(dfeUInt(3),0);
			//					eof = constant.value(dfeBool(),1);
			//					sof = constant.value(dfeBool(),1);
			//					//socket=constant.value(dfeUInt(8),0);
			//					//output.valid<==true;
			//					//output<== sof # eof # mod # socket # data;
			//					output<== sof # eof # mod # socket # data;
			//
			//					debug.simPrintf("tick=%u, Petlja 2 - Adresa: %d, eof=%x,sof=%x, data=%x\n", counter,sCurrentROMAddress,eof,sof,data);
			//				}
			//
			//				output.valid<== true;//~output.stall;
			//}



			//debug.simPrintf("tick=%u, output.valid=%x, output.stall=%x\n",counter, output.valid,output.stall);
		}

		//dataLengthBytes<==((sEndROMAddress-1)-(sStartROMAddress+1) + 1)*8;
		//dataLengthBytes.valid<==true;

		//LMem
		output.valid <== false;
		output<==0;
		dataFromMem.stall<==output.stall;

		//debug.simPrintf("tick=%u, output.valid=%x, output.stall=%x, dataFromMem.valid=%u\n",counter, output.valid,output.stall,dataFromMem.valid);




		IF(dataFromMem.valid & ~sAllBytesSentFlag)
		{
			//default
			DFEsmValue data,mod,eof,sof;
			data = dataFromMem;
			mod = constant.value(dfeUInt(3),0);
			eof = constant.value(dfeBool(),1);
			sof = constant.value(dfeBool(),1);

			output.valid <== dataFromMem.valid;
			output<== sof # eof # mod # socket # data;

			//if case
			IF(sFileLengthBytesCounter>=sFileLengthBytes)
			{
				output.valid <== dataFromMem.valid;

				//DFEsmValue data,mod,eof,sof;
				data = dataFromMem;

				DFEsmAssignableValue difference = assignable.value(dfeUInt(26));
				difference <== 8 - (sFileLengthBytesCounter-sFileLengthBytes);
				IF(difference===8) difference <== 0;

				mod = difference.cast(dfeUInt(3));//constant.value(dfeUInt(3),0);
				eof = constant.value(dfeBool(),1);
				sof = constant.value(dfeBool(),1);

				debug.simPrintf("Tick=%u, slanje: mod=%u, sFileLengthBytesCounter=%u, sFileLengthBytes=%u\n", counter, mod, sFileLengthBytesCounter, sFileLengthBytes);

				output<== sof # eof # mod # socket # data;



				//debug.simPrintf("\nKRAJ podataka za output, fromStateMachineDataSentFlag=%u, Tick=%u \n\n",fromStateMachineDataSentFlag,counter);
			}
		}

//		//signal for CPU: socket close
//		IF(sCloseSocketCycleFlag)
//		{
//
//			IF(sCloseSocketCycleCounter<17)
//			{
//				//posalji strim
//				//IF(~fromStateMachineDataSentFlag.stall)
//				{
//					fromStateMachineDataSentFlag.valid<==true;
//					fromStateMachineDataSentFlag<==socket;
//				}
//
//				debug.simPrintf("sCloseSocketCycleCounter=%u, Tick=%u\n",sCloseSocketCycleCounter,counter);
//			}
//		}


		fromStateMachineByteNumber.valid<==false;
		fromStateMachineByteNumber<==0;

		IF(sCloseSocketCycleFlag)
		{
			fromStateMachineByteNumber.valid<==true;
			fromStateMachineByteNumber<==sFileLengthBytes.cast(dfeUInt(128));
		}

//		IF(dataFromMem.valid)
//		{
//			debug.simPrintf("BYTELENGTH Tick=%u, fromStateMachineByteNumber.valid=%x, fromStateMachineByteNumber=%u\n",sCounter,fromStateMachineByteNumber.valid,fromStateMachineByteNumber);
//		}


		input.stall <== output.stall;

		String konstanta = String.format("%d", new BigInteger(1,"GE".getBytes())); //konvertuj string "GET " u hex oblik
		System.out.println("Konvertovani oblik " + konstanta);
		int width=32;
		DFEsmValue methodBits = constant.value(dfeUInt(width),new BigInteger(1,"GET ".getBytes()));

		memCmdOutput<==0;
		memCmdOutput.valid<==false;

		IF(~sMemCmdOutputStall) //
		{
			//komande za memorijski kontroler
			memCmdOutput <== memCmdReg;
			memCmdOutput.valid <== memCmdRegValid;

			IF (memCmdRegValid)
			{
				debug.simPrintf("tick=%u, memCmdOutput.stall=%u, Pushing out memory command***: %x\n", counter, memCmdOutput.stall, memCmdReg);
				//debug.simPrintf("Pushing DATA=%x\n", 11);
			}

		}

			//debug.simPrintf("Tick=%u, memCmdOutput=%x, memCmdOutput.valid=%x\n",sCounter,memCmdReg,memCmdRegValid);





//		IF(sLMemBytesSent===(sDataBurstLength-1)*192)
//		{
//			fromStateMachineDataSentFlag<==1;
//			fromStateMachineDataSentFlag.valid<==true;
//
//			debug.simPrintf("SVE poslato na output iz LMem: %x\n", sLMemBytesSent);
//		}


//		IF(sHashIndexValid===true)
//		{
//		  DFEsmAssignableValue ttt=assignable.value(dfeUInt(64));
//          debug.simPrintf("outputFunction() Postavljam romHashIndex.address na=%u, current=%u\n", sRomHashIndexAddress,counter);
//          ttt<==romHashIndex.dataOut;
//          debug.simPrintf("outputFunction() Vrednost romHashIndex.dataOut=%x, current=%u\n", romMemorija.dataOut,counter);
//
//		}


		//smOutput <== sCounter;

		//IF(sCurrentState===Stanje.prijemURI)
		{
			//smOutput <== constant.value(dfeUInt(32), 55);
			//smOutput <== sCounter;
			//smOutput <== sHoldCounter;

			//smOutput <== sCounter;
			//smTest   <== sHoldCounter; //constant.value(dfeUInt(16), 47);
			//smBajt   <== bajt1;
		}

		//smOutput <== bajt1.cat(bajt2).cast(dfeUInt(32));//sCounter;
		//smOutput <== bajt1.cast(dfeUInt(32));//sCounter;

		IF(dataFromMem.valid)
		{
		  debug.simPrintf("Tick=%u, output=%x, output.valid=%u, sFileLengthBytesCounter=%u, sFileLengthBytes=%u\n", counter, output,output.valid, sFileLengthBytesCounter, sFileLengthBytes);
		}

	}


	private void doHashFunction(DFEsmAssignableValue result,
								DFEsmAssignableValue[] inputs,
								DFEsmAssignableValue startIndex,
								DFEsmAssignableValue endIndex)
	{
		//result<==result + inputs[4].cast(dfeUInt(16));
		//result<==result + inputs[5].cast(dfeUInt(16));
		//result<==0;
		for(int i=0;i<inputs.length;i++)
		{
			IF((i>=startIndex) & (i<=endIndex))
			{
				//debug.simPrintf("Ovaj uslov=%d je ispunjen\n", i);
				result<==result + inputs[i].cast(dfeUInt(15));
			}
		}
	}

	//method used to fill Bram ie FMem
	//with some initial contents from the file
	private long[] fillBRam(String fileLocation,boolean convertAsciiToInt, boolean reverseCharsFlag)
	{

		File file= new File(fileLocation);
		int L = (int) file.length();
		double diff = Math.ceil(L/8.0) - L/8.0; //dopunjavanje NULL characterom do celobrojonog umnoska bajtova (1B=8 bita)

		char niz[]=new char[L];
		if (diff!=0)
		{
			niz = new char[(int) Math.ceil(L/8.0)*8];
		}

		System.out.println("L=" + L + ", diff=" + diff + ", duzina niz[]=" + niz.length);
		//long
		long initArray[]=new long[niz.length/8];

		try {
			FileReader b = new FileReader(fileLocation);
			b.read(niz);
		} catch (Exception e) {
			// TODO: handle exception
		}

		//System.arraycopy(niz, 0, HTMLarray, 0, niz.length);

		if(convertAsciiToInt)
		{
			for(int i=0;i<niz.length;i++)
			{
//				switch (niz[i]) {
//				case 'A':
//					niz[i]=10;
//					break;
//
//				case 'B':
//					niz[i]=11;
//					break;
//
//				case 'C':
//					niz[i]=12;
//					break;
//
//				case 'D':
//					niz[i]=13;
//					break;
//
//				case 'E':
//					niz[i]=14;
//					break;
//
//				case 'F':
//					niz[i]=15;
//					break;


//				default:
//					niz[i]=(char) (niz[i]-'0');
//					break;


				//}

			niz[i]=(char) (niz[i]-'0');
				 //convert each charactr to its decimal value '0'->0;'1'->1...
				//System.out.println(niz[i]);
			}
		}


		for(int j=0;j<initArray.length;j++)
		{
			StringBuilder sb=new StringBuilder(0);
			for(int t=j*8;t<j*8+8;t++)
			{
				sb.append(niz[t]);
			}

			//HTMLarray[0]=sb.toString().getBytes();

			if(reverseCharsFlag) sb.reverse();

			ByteBuffer word = ByteBuffer.wrap(sb.toString().getBytes());

			long temp=word.getLong();
			//System.out.printf("%x\n",temp);
			initArray[j]=temp;
			//System.out.println(Long.parseLong(sb.toString()));

			//BigInteger(1,"GET ".getBytes()));

		}

		return initArray;

	}

	private void makeWaitFlagCommand(DFEsmStateValue cmdReg, int streamIx, DFEsmValue flags, boolean untilSet) {
		SMUtils.assignField(cmdReg.next, cmdType, "address", flags);
		SMUtils.assignField(cmdReg.next, cmdType, "size", 0);
		SMUtils.assignField(cmdReg.next, cmdType, "inc", untilSet ? MemCommand.BlockUntilFlagsSet.getInstructionCode() :
																	MemCommand.BlockUntilFlagsCleared.getInstructionCode());
		SMUtils.assignField(cmdReg.next, cmdType, "tag", 0);
		SMUtils.assignField(cmdReg.next, cmdType, "stream", 1 << streamIx);
	}

	private void makeSetFlagCommand(DFEsmStateValue cmdReg, int streamIx, DFEsmValue flag, boolean set) {
		SMUtils.assignField(cmdReg.next, cmdType, "address", flag);
		SMUtils.assignField(cmdReg.next, cmdType, "size", 0);
		SMUtils.assignField(cmdReg.next, cmdType, "inc", set ? MemCommand.SetFlags.getInstructionCode() :
															   MemCommand.ClearFlags.getInstructionCode());
		SMUtils.assignField(cmdReg.next, cmdType, "tag", 0);
		SMUtils.assignField(cmdReg.next, cmdType, "stream", 1 << streamIx);
	}

	private void makeReadOrWriteCommand(DFEsmStateValue cmdReg, DFEsmValue address, int streamIx) {
		SMUtils.assignField(cmdReg.next, cmdType, "address", address);
		SMUtils.assignField(cmdReg.next, cmdType, "size", 1);
		SMUtils.assignField(cmdReg.next, cmdType, "inc", 1);
		SMUtils.assignField(cmdReg.next, cmdType, "tag", 0);
		SMUtils.assignField(cmdReg.next, cmdType, "stream", 1 << streamIx);
	}

	//private void makeControlCommand(DFEsmStateValue cmdReg,  MemCommand cmd, int flagIx) {
//		SMUtils.assignField(cmdReg.next, cmdType, "address", 1 << flagIx);
//		SMUtils.assignField(cmdReg.next, cmdType, "size", 0);
//		SMUtils.assignField(cmdReg.next, cmdType, "inc", cmd.getInstructionCode());
//		SMUtils.assignField(cmdReg.next, cmdType, "tag", 0);
	//}

}



//try {
////System.out.println("izlaz" + System.getProperty("user.dir"));
////FileReader b = new FileReader("/home/mvorkapic/Desktop/test.html");
//FileReader b = new FileReader(fileLocation);
//b.read(niz);
//String fileString=Arrays.toString(niz); //od char niza napravi string
//
////System.out.println("Niz: " + Arrays.toString(niz));
//double u=Math.ceil(L/8.0);
//
//System.out.println("Duzina fajla: " + L + ", Broj bajtova nakon grupisanja: " + u);
//System.out.println("FILE: " + fileString + "Duzina: "+ fileString.codePointCount(0, fileString.length()));
////double diff = Math.ceil(L/8.0) - L/8.0; //dopunjavanje NULL characterom do celobrojonog umnoska bajtova (1B=8 bita)
//if (diff!=0)
//{
//	char nullarray[]=new char[20]; //(int) Math.ceil(diff)
//	fileString = fileString + Arrays.toString(nullarray);
//
//}
//
//System.out.println("novi FILE: " + fileString);
//System.out.println("nova Duzina: "+ fileString.length() + " diff=" + diff);
//int y=7/0;
//
//for(int j=0;j<u;j++)
//{
//	StringBuilder sb=new StringBuilder(0);
//	for(int t=j*8;t<j*8+8;t++)
//	{
//		sb.append(niz[t]);
//	}
//
//	//HTMLarray[0]=sb.toString().getBytes();
//	sb.reverse();
//	ByteBuffer word = ByteBuffer.wrap(sb.toString().getBytes());
//
//	long temp=word.getLong();
//	//System.out.printf("%x\n",temp);
//	HTMLarray[j]=temp;
//	//System.out.println(Long.parseLong(sb.toString()));
//
//	//BigInteger(1,"GET ".getBytes()));
//
//}

//int i=9/0;

//int p=7/0;
//		        char line = br.read(cbuf);
//		        br.re
//
//		        while (line != null) {
//		            sb.append(line);
//		            sb.append(System.lineSeparator());
//		            line = br.readLine();
//		        }
//		        String everything = sb.toString();
//} catch (FileNotFoundException e) {
//// TODO Auto-generated catch block
//e.printStackTrace();
//} catch (IOException e) {
//// TODO Auto-generated catch block
//e.printStackTrace();
//} finally {
//
//}

//for(int i=0;i<niz.length;i++)
//{
//
//HTMLarray[i]=niz[i]; //rom initializaction with single static page
//}
