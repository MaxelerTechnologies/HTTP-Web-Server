package stamp;

import com.maxeler.maxcompiler.v2.managers.DFEManager;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateValue;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPullOutput;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushInput;
import com.maxeler.maxcompiler.v2.statemachine.manager.ManagerStateMachine;
import com.maxeler.maxcompiler.v2.statemachine.stdlib.Buffer.BufferSpec;
import com.maxeler.maxcompiler.v2.statemachine.stdlib.Buffer.DFEsmFifoConfig;
import com.maxeler.maxcompiler.v2.statemachine.stdlib.buffer.DFEsmFifo;
import com.maxeler.maxcompiler.v2.statemachine.types.DFEsmValueType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;


/**
 * FIFO state machine with a limited depth to prevent stale data.
 *
 * @author simon
 */
public class LimitedDepthFIFOcopy extends ManagerStateMachine {
	private final int m_almostEmptyStartCount;

	private final DFEsmPushInput m_input;
	private final DFEsmPushInput m_read;
	private final DFEsmPullOutput m_output;
	private final DFEsmFifo m_fifo;
	private final DFEsmStateValue m_almostEmptyCounter;

	/**
	 * Default constructor to create a {@link LimitedDepthFIFOcopy} instance.
	 *
	 * @param owner Parent manager.
	 * @param params Application parameters.
	 * @param width Bit width of data.
	 * @param inLatency Push input latency.
	 * @param outLatency Pull output latency.
	 */
	public LimitedDepthFIFOcopy(final DFEManager owner, final int width,
			final int inLatency, final int outLatency) {
		super(owner);

		final DFEsmValueType type = dfeUInt(width);

		m_input = io.pushInput("input", type, inLatency);
		m_output = io.pullOutput("output", type, outLatency);
		m_read = io.pushInput("m_read", type, outLatency);

		// computer says FIFO depth must be a power of two
		// we add one to the number to have a minimum slack of 2
		// items before stalling input
		// It also says depths of less than 8 are bad... I found
		// Xilinx's doc for FIFOs and it says min depth is 16
		// http://www.xilinx.com/support/documentation/ip_documentation/fifo_generator_ug175.pdf
		final int fifoDepth = Math.max(16, 1 <<
				(MathUtils.bitsToAddress(Math.max(inLatency, outLatency)+2)));

		final int progEmptyLatency = Math.max(outLatency, 7);
		m_almostEmptyStartCount = progEmptyLatency - outLatency;

		final DFEsmFifoConfig fifoConfig = new DFEsmFifoConfig()
				.setBufferSpec(BufferSpec.UseLUTRam)
				.setProgrammableFull(fifoDepth - Math.max(inLatency + 2, 7))
				.setProgrammableEmpty(progEmptyLatency);
		m_fifo = buffer.fifo(type, fifoDepth, fifoConfig);

		if (m_almostEmptyStartCount > 0) {
			m_almostEmptyCounter = state.value(dfeUInt(
					MathUtils.bitsToRepresentUnsigned(m_almostEmptyStartCount)), 0);
		} else {
			m_almostEmptyCounter = null;
		}
	}

	/*
	 * (non-Javadoc)
	 * @see com.maxeler.maxcompiler.v1.statemachine.StateMachine#nextState()
	 */
	@Override
	protected void nextState() {
		m_fifo.input.writeEnable <== m_input.valid;
		m_fifo.input.dataIn <== m_input;
		m_fifo.output.readEnable <== m_read.valid; //m_output.read;
		if (null != m_almostEmptyCounter) {
			IF (m_fifo.output.progEmpty) {
				IF (m_output.read & ~m_input.valid & m_almostEmptyCounter.gt(0)) {
					m_almostEmptyCounter.next <== m_almostEmptyCounter - 1;
				}
			} ELSE {
				m_almostEmptyCounter.next <== m_almostEmptyStartCount;
			}
		}

		//debug.simPrintf("m_fifo.input.dataIn=%x\n",m_input);
	}

	/*
	 * (non-Javadoc)
	 * @see com.maxeler.maxcompiler.v1.statemachine.StateMachine#outputFunction()
	 */
	@Override
	protected void outputFunction() {
		m_input.stall <== m_fifo.input.progFull;
		m_output.empty <== m_fifo.output.empty;
		if (null != m_almostEmptyCounter) {
			m_output.almostEmpty <== m_almostEmptyCounter.eq(0);
		} else {
			m_output.almostEmpty <== m_fifo.output.progEmpty;
		}
		m_output <== m_fifo.output.dataOut;

//		IF(m_input.valid)
//		{
//			debug.simPrintf("m_fifo.output.dataOut=%x\n",m_fifo.output.dataOut);
//		}
	}
}
