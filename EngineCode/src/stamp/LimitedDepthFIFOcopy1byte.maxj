package stamp;

import com.maxeler.maxcompiler.v2.managers.DFEManager;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmAssignableValue;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateValue;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmValue;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushInput;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushOutput;
import com.maxeler.maxcompiler.v2.statemachine.manager.ManagerStateMachine;
import com.maxeler.maxcompiler.v2.statemachine.stdlib.Buffer.BufferSpec;
import com.maxeler.maxcompiler.v2.statemachine.stdlib.Buffer.DFEsmFifoConfig;
import com.maxeler.maxcompiler.v2.statemachine.stdlib.buffer.DFEsmFifo;
import com.maxeler.maxcompiler.v2.statemachine.types.DFEsmValueType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;


/**
 * FIFO state machine with a limited depth to prevent stale data.
 *
 * @author simon
 */
public class LimitedDepthFIFOcopy1byte extends ManagerStateMachine {
	private final int m_almostEmptyStartCount;

	private final DFEsmPushInput m_input;
	private final DFEsmPushOutput m_read;
	//private final DFEsmPullOutput m_output;
	private final DFEsmFifo m_fifo;
	private final DFEsmStateValue m_almostEmptyCounter;
	private final DFEsmStateValue sRead8Bytes = state.value(dfeBool(),false);

	/**
	 * Default constructor to create a {@link LimitedDepthFIFOcopy1byte} instance.
	 *
	 * @param owner Parent manager.
	 * @param params Application parameters.
	 * @param width Bit width of data.
	 * @param inLatency Push input latency.
	 * @param outLatency Pull output latency.
	 */
	public LimitedDepthFIFOcopy1byte(final DFEManager owner, final int width,
			final int inLatency, final int outLatency) {
		super(owner);

		final DFEsmValueType type = dfeUInt(width);

		m_input = io.pushInput("input", type, inLatency);
		//m_output = io.pullOutput("output", type, outLatency);
		m_read = io.pushOutput("m_read", dfeBool(), outLatency);

		// computer says FIFO depth must be a power of two
		// we add one to the number to have a minimum slack of 2
		// items before stalling input
		// It also says depths of less than 8 are bad... I found
		// Xilinx's doc for FIFOs and it says min depth is 16
		// http://www.xilinx.com/support/documentation/ip_documentation/fifo_generator_ug175.pdf
		final int fifoDepth = Math.max(16, 1 <<
				(MathUtils.bitsToAddress(Math.max(inLatency, outLatency)+2)));

		final int progEmptyLatency = Math.max(outLatency, 7);
		m_almostEmptyStartCount = progEmptyLatency - outLatency;

		final DFEsmFifoConfig fifoConfig = new DFEsmFifoConfig()
				.setBufferSpec(BufferSpec.UseLUTRam)
				.setProgrammableFull(fifoDepth - Math.max(inLatency + 2, 7))
				.setProgrammableEmpty(progEmptyLatency);
		m_fifo = buffer.fifo(type, fifoDepth, fifoConfig);

		if (m_almostEmptyStartCount > 0) {
			m_almostEmptyCounter = state.value(dfeUInt(
					MathUtils.bitsToRepresentUnsigned(m_almostEmptyStartCount)), 0);
		} else {
			m_almostEmptyCounter = null;
		}
	}

	/*
	 * (non-Javadoc)
	 * @see com.maxeler.maxcompiler.v1.statemachine.StateMachine#nextState()
	 */
	@Override
	protected void nextState() {
		m_fifo.input.writeEnable <== m_input.valid;
		m_fifo.input.dataIn <== m_input;
		m_fifo.output.readEnable <== sRead8Bytes; //m_output.read;
//		if (null != m_almostEmptyCounter) {
//			IF (m_fifo.output.progEmpty) {
//				IF (m_output.read & ~m_input.valid & m_almostEmptyCounter.gt(0)) {
//					m_almostEmptyCounter.next <== m_almostEmptyCounter - 1;
//				}
//			} ELSE {
//				m_almostEmptyCounter.next <== m_almostEmptyStartCount;
//			}
//		}

		sRead8Bytes.next <== true;

		IF(sRead8Bytes===true)
		{
			sRead8Bytes.next <== false;
		}

		DFEsmAssignableValue data = assignable.value(dfeUInt(64));
		DFEsmAssignableValue startIndex = assignable.value(dfeUInt(3));
		DFEsmAssignableValue endIndex = assignable.value(dfeUInt(3));
		DFEsmAssignableValue length =  assignable.value(dfeUInt(64));
		length <== endIndex-startIndex;

		IF(m_input.valid)
		{
			data <== m_input.slice(6, 64);
			startIndex <== m_input.slice(0, 3);
			endIndex <== m_input.slice(3, 3);

			DFEsmAssignableValue bytes[]=new DFEsmAssignableValue[8];

			final  DFEsmValue bajtovi[] = new DFEsmValue[8];

			bajtovi[0]=data.slice(0, 8).cast(dfeUInt(8)); //  #1
			bajtovi[1]=data.slice(8, 8).cast(dfeUInt(8)); //  #2
			bajtovi[2]=data.slice(16, 8).cast(dfeUInt(8)); // #3
			bajtovi[3]=data.slice(24, 8).cast(dfeUInt(8)); // #4
			bajtovi[4]=data.slice(32, 8).cast(dfeUInt(8)); // #5
			bajtovi[5]=data.slice(40, 8).cast(dfeUInt(8)); // #6
			bajtovi[6]=data.slice(48, 8).cast(dfeUInt(8)); // #7
			bajtovi[7]=data.slice(56, 8).cast(dfeUInt(8)); // #8

			for(int u=0;u<8;u++)
			{
				bytes[u]=assignable.value(dfeUInt(8));
				bytes[u]<==bajtovi[u];
				IF(bajtovi[u]===' ')
				{
					bytes[u]<==0;
				}
			}


			for(int i=0;i<bytes.length;i++)
			{
				IF((i>=startIndex) & (i<=endIndex))
				{
					//debug.simPrintf("Ovaj uslov=%d je ispunjen\n", i);
					//result<==result + inputs[i].cast(dfeUInt(15));
				}
			}
		}



		//debug.simPrintf("m_fifo.input.dataIn=%x\n",m_input);
	}

	/*
	 * (non-Javadoc)
	 * @see com.maxeler.maxcompiler.v1.statemachine.StateMachine#outputFunction()
	 */
	@Override
	protected void outputFunction() {
		m_input.stall <== m_fifo.input.progFull;
		//m_output.empty <== m_fifo.output.empty;
//		if (null != m_almostEmptyCounter) {
//			m_output.almostEmpty <== m_almostEmptyCounter.eq(0);
//		} else {
//			m_output.almostEmpty <== m_fifo.output.progEmpty;
//		}
		//m_output <== m_fifo.output.dataOut;

		IF(m_input.valid)
		{
			debug.simPrintf("m_fifo.output.dataOut=%x\n",m_fifo.output.dataOut);
		}
	}
}
