package httpserver;


import java.util.ArrayList;

import com.maxeler.maxcompiler.v2.managers.DFEManager;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateValue;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmValue;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPullOutput;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushInput;
import com.maxeler.maxcompiler.v2.statemachine.manager.ManagerStateMachine;
import com.maxeler.maxcompiler.v2.statemachine.stdlib.Buffer.BufferSpec;
import com.maxeler.maxcompiler.v2.statemachine.stdlib.Buffer.DFEsmFifoConfig;
import com.maxeler.maxcompiler.v2.statemachine.stdlib.buffer.DFEsmFifo;
import com.maxeler.maxcompiler.v2.statemachine.types.DFEsmValueType;

public class CRCIndexFIFO extends ManagerStateMachine {

	int Nsockets = 1;
	//private final DFEsmPushInput inputTcpData = io.pushInput("tcp_to_sm", dfeUInt(77), 1);
	private final ArrayList<DFEsmPushInput> inputPorts = new ArrayList<DFEsmPushInput>(Nsockets);
	private final ArrayList<DFEsmPullOutput> outputPorts = new ArrayList<DFEsmPullOutput>(Nsockets);

	//private final DFEsmPushInput m_input;
	//private final DFEsmPullOutput m_output;
	private final DFEsmFifo[] m_fifo = new DFEsmFifo[Nsockets];
	//private final DFEsmStateValue m_almostEmptyCounter;
	private final DFEsmStateValue sReadEnable = state.value(dfeBool(), 0);

	public CRCIndexFIFO(DFEManager owner) {
		super(owner);

		int width = 64; //
		for(int i=0;i<Nsockets;i++)
		{
			String inputName = "outputCrcFIFOInput" + String.valueOf(i);
			inputPorts.add(io.pushInput(inputName, dfeUInt(width), 1));

			String outputName = "outputCrcFIFOOutput" + String.valueOf(i);
			outputPorts.add(io.pullOutput(outputName, dfeUInt(width), 1));
		}

		final DFEsmValueType type = dfeUInt(width);

		//m_input = io.pushInput("input", type, inLatency);
		//m_output = io.pullOutput("output", type, outLatency);

		// computer says FIFO depth must be a power of two
		// we add one to the number to have a minimum slack of 2
		// items before stalling input
		// It also says depths of less than 8 are bad... I found
		// Xilinx's doc for FIFOs and it says min depth is 16
		// http://www.xilinx.com/support/documentation/ip_documentation/fifo_generator_ug175.pdf
		final int fifoDepth = 256; //Math.max(16, 1 <<	(MathUtils.bitsToAddress(Math.max(inLatency, outLatency)+2)));

		final int progEmptyLatency = 5; //Math.max(outLatency, 7);
		//m_almostEmptyStartCount = progEmptyLatency - outLatency;

		final DFEsmFifoConfig fifoConfig = new DFEsmFifoConfig()
				.setBufferSpec(BufferSpec.UseLUTRam)
				.setProgrammableFull(fifoDepth)
				.setProgrammableEmpty(progEmptyLatency)
				.setHasValidFlag()
				.setHasDataCount();


		for(int i=0;i<Nsockets;i++)
		{
			m_fifo[i] = buffer.fifo(type, fifoDepth, fifoConfig);
		}



//		if (m_almostEmptyStartCount > 0) {
//			m_almostEmptyCounter = state.value(dfeUInt(
//					MathUtils.bitsToRepresentUnsigned(m_almostEmptyStartCount)), 0);
//		} else {
//			m_almostEmptyCounter = null;
//		}

	}

	@Override
	protected void nextState() {
//		m_fifo.input.writeEnable <== m_input.valid;
//		m_fifo.input.dataIn <== m_input;
//		m_fifo.output.readEnable <== m_output.read;
//		if (null != m_almostEmptyCounter) {
//			IF (m_fifo.output.progEmpty) {
//				IF (m_output.read & ~m_input.valid & m_almostEmptyCounter.gt(0)) {
//					m_almostEmptyCounter.next <== m_almostEmptyCounter - 1;
//				}
//			} ELSE {
//				m_almostEmptyCounter.next <== m_almostEmptyStartCount;
//			}
//		}

		//sReadEnable.next <== false;
		for(int i=0;i<Nsockets;i++)
		{
			// input
			m_fifo[i].input.writeEnable <== inputPorts.get(i).valid;
			m_fifo[i].input.dataIn <== inputPorts.get(i);

			// output
			m_fifo[i].output.readEnable <== outputPorts.get(i).read;
			//IF(outputPorts.get(i).read) sReadEnable.next <== true;

		}

	}

	@Override
	protected void outputFunction() {


		DFEsmValue socket = null;

		for(int i=0;i<Nsockets;i++)
		{
			//outputPorts.get(i) <== 0;
			//outputPorts.get(i). <== false;
			inputPorts.get(i).stall <== m_fifo[i].input.progFull;

			outputPorts.get(i).empty <== m_fifo[i].output.empty;
			outputPorts.get(i) <== m_fifo[i].output.dataOut;

			IF(outputPorts.get(i).read)
			{
				debug.simPrintf("CRCIndexFIFO: SETOVAN outputPorts.get(i).read=%u\n", outputPorts.get(i).read);
			}


			IF(inputPorts.get(i).valid) //sReadEnable
			{
				debug.simPrintf( "CRCIndexFIFO: m_fifo[%d].output.dataOut=%x, outputPorts.get(i).read=%u\n",i, m_fifo[i].output.dataOut, outputPorts.get(i).read);
			}
		}



		//outputPorts.get(0).empty <== m_fifo.output.empty;



//		m_input.stall <== m_fifo.input.progFull;
//		m_output.empty <== m_fifo.output.empty;
//		if (null != m_almostEmptyCounter) {
//			m_output.almostEmpty <== m_almostEmptyCounter.eq(0);
//		} else {
//			m_output.almostEmpty <== m_fifo.output.progEmpty;
//		}
//		m_output <== m_fifo.output.dataOut;
//

	}

}
