package httpserver;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.SMIO;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.DelimiterMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingInput;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.networking.statemachines.Flushing;
import com.maxeler.networking.types.TCPManyConnectionsTypes;
import com.maxeler.networking.types.TCPManyConnectionsTypes.RxDataRespType;

public class Http_Kernel extends Kernel {

    public static final String dataIn = "dataIn_Http";
	public static final String dataOut = "dataOut_Http";

	public Http_Kernel(KernelParameters parameters, TCPManyConnectionsTypes tcpTypes) {
		super(parameters);

		flush.disabled();

		DFEStructType rxDataRespType = tcpTypes.getRxDataRespType();

		NonBlockingInput<DFEStruct> inputStruct = io.nonBlockingInput(dataIn,
	    		rxDataRespType,
	    		constant.var(true) /* Always enabled */,
	    		rxDataRespType.getPositionForField(RxDataRespType.EOF),
	    		DelimiterMode.FRAME_LENGTH,
	    		Flushing.interFrameGapNone,
	    		NonBlockingMode.NO_TRICKLING);

	    DFEStruct dataStruct = inputStruct.data; //'data' contains TCP fields: data, socket, sof, eof, mod
		DFEVar valid = inputStruct.valid;

		DFEVar sof = dataStruct[RxDataRespType.SOF];
		DFEVar eof = dataStruct[RxDataRespType.EOF];
		DFEVar mod = dataStruct[RxDataRespType.MOD];
		DFEVar data = dataStruct[RxDataRespType.DATA];
		DFEVar socket = dataStruct[RxDataRespType.SOCKET];

		//debug.simPrintf(valid, "HttpKernel: data=%x, valid=%u\n", data, valid);

		DFEVar counter = control.count.makeCounter(
				control.count.makeParams(24)
				.withEnable(constant.var(true))
				.withInitValue(0)
				.withWrapMode(WrapMode.STOP_AT_MAX)
				).getCount();

		debug.simPrintf(valid, "HttpKernel: tick=%u, data=%x, valid=%u\n", counter, data, valid);

		SMIO httpSM = addStateMachine("httpSM", new httpSM(this, tcpTypes));
		httpSM.connectInput("valid", valid); //valid
		httpSM.connectInput("test", constant.var(true)); //valid
		httpSM.connectInput("dataHttpSM", (sof # eof # mod # socket # data).cast(dfeUInt(75)));
		//DFEVar output = httpSM.getOutput("output");

//caseSTART(4);

		//Steps:
		// get current state from SM
		// do processing based on the current state
		// set new state in SM

		DFEVar checksumOutput = httpSM.getOutput("checksumOutput");
		DFEVar socketNumberOutput = httpSM.getOutput("socketNumberOutput");
		DFEVar schedulerValidOutput = httpSM.getOutput("schedulerValidOutput");
		DFEVar oStoreURLValid = httpSM.getOutput("oStoreURLValid");
		//DFEVar oCurrentState = httpSM.getOutput("oCurrentState");


		//control.mux to select between multiple input streams, instead of ternary operator
		//DFEVar valid0 = oCurrentState === 0;
		//DFEVar sel = oCurrentState === 0;


		io.output("checksumOutput", checksumOutput.getType(), oStoreURLValid) <== checksumOutput;
		io.output("socketNumberOutput", socketNumberOutput.getType(), oStoreURLValid) <== socketNumberOutput;
		//io.output("schedulerValidOutput", schedulerValidOutput.getType(), schedulerValidOutput) <== schedulerValidOutput;

		debug.simPrintf(schedulerValidOutput | oStoreURLValid, "HttpKernel: data=%x, checksumOutput=%x, socketNumberOutput=%u, schedulerValidOutput=%u, oStoreURLValid=%u, valid=%u\n", data, checksumOutput, socketNumberOutput, schedulerValidOutput, oStoreURLValid, valid);

	}

//	private DFEVar caseSTART(int tt)
//	{
//
//		DFEVar methodGET = constant.value(dfeUInt(width),new BigInteger(1,"GET ".getBytes()));
//		//DFEVar n4bytes = byte1 # byte2 # byte3 # byte4;
//		DFEVar sum = constant.var(dfeUInt(4), 0); //assignable.value(dfeUInt(4));
//
//		DFEVar wwDfeVar = n4bytes === methodGET;
//		DFEVar dummy;
//
//
//		DFEVar nextState;
//		//DFEVar sStoreURL;
//
//
//		DFEVar startIndex= 7;
//		DFEVar endIndex= 0;
//
//		for(int i=0;i<8;i++)
//		{
//			startIndex = (dataBytes[i]===' ') & (i<startIndex)?  i : startIndex;
//			endIndex =(dataBytes[i]===' ') & (i>endIndex)? i: endIndex; //false
//
//			sum=sum+1;
//		}
//
//		//IF (wwDfeVar)
//		{
//
//			//IF(byte4===' ')
//			{
//
////				IF(sum>=2)
////			{
//					startIndex =(sum>=2)?  startIndex+1 : startIndex+1;
//					endIndex =  (sum>=2)?  endIndex-1 : 7; //false
//
//					//debug.simPrintf("httpSM: sum>=2, startIndex=%u, endIndex=%u\n",startIndex,endIndex);
////				}
////				ELSE
////				{
////					//if sum=0 or sum=1
////					startIndex<==;
////					endIndex<==7;
////				}
//
//				//debug.simPrintf("httpSM: sum sum=%u, startIndex=%u, endIndex=%u\n",sum,startIndex,endIndex);
//
//				DFEVar bytes[]=new DFEVar[8];
//				for(int u=0;u<8;u++)
//				{
//					//bytes[u]=assignablevalue(dfeUInt(8));
//					bytes[u]<==dataBytes[u];
//					bytes[u]= (dataBytes[u]===' ') ? 0 : bytes[u];
//									}
//
//				for(int t=0;t<8;t++)
//				{
//					//debug.simPrintf("httpSM: sum Start bytes[%d]=%u\n",t,bytes[t]);
//				}
//
//				//debug.simPrintf("httpSM: startIndex=%u, endIndex=%u\n",startIndex,endIndex);
//
//				DFEVar startIndexBit = startIndex.cast(dfeUInt(8))*8;
//				DFEVar endIndexBit = endIndex.cast(dfeUInt(8))*8+7;
//
//				DFEVar bitNumber = constant.var(dfeUInt(9), 0);
//				DFEVar sStoreURL = constant.var(dfeUInt(0), 0);
//
//
//				int bitPointer = 0;
//
//				for(int i=0;i<8;i++)
//				{
//					sStoreURL = (DFEVar) (((i>=startIndex) & (i<=endIndex)) ? checking() : do_nothing());
//					bitNumber = ((i>=startIndex) & (i<=endIndex)) ? bitNumber + 8 : bitNumber;
//
//					bitPointer=bitPointer+8;
//
//					//debug.simPrintf("httpSM: TEST: bitPointer=%u\n", bitPointer);
//				}
//
//				//debug.simPrintf("httpSM: TEST: startIndex=%u, endIndex=%u, startIndexBit=%u, endIndexBit=%u, bitNumber=%u, sStoreURL=%x\n", startIndex, endIndex, startIndexBit, endIndexBit, bitNumber, sStoreURL);
//
//				sBitNumber.next <== bitNumber;
//
//			}
//
//
//			nextState = (sum>=2) ? States.HTTP_VERSION : States.URI; //from index 4 to index 7
//			//{
//				//some part of HTTP part was already received
//				//sCurrentState.next<==States.HTTP_VERSION;
//				//debug.simPrintf("httpSM: nextState: HTTP_VERSION: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
//
//			//}
////			ELSE {
////				sCurrentState.next<==States.URI;
////				debug.simPrintf("httpSM: nextState: URI: tick=%u, sNumericCurrent=%u, data=%x\n", counter,sCurrentState,data);
////			}
//		}
//
//
//
//
//		return tt;
//	}
//
//	private DFEVar checking(DFEVar sStoreURL, DFEVar bytes[], int i, DFEVar bitNumber)
//	{
//
//
//		//List<DFEVar> signBits = new ArrayList<DFEVar>(8);
//
//		sStoreURL = bytes[i] # sStoreURL;
//
//
////		for(int j=0;j<8;j++)
////		{
////			//control.mux(bitNumber,  bytes[i].slice(j, 1));
////			sStoreURL = (bitNumber === 0) ? bytes[i] # sStoreURL : sStoreURL;
////			sStoreURL[8+j] = (bitNumber === 8) ?  bytes[i].slice(j, 1) : sStoreURL[8+j];
////			sStoreURL[16+j] = (bitNumber === 16) ?  bytes[i].slice(j, 1) : sStoreURL[16+j];
////			sStoreURL[24+j] = (bitNumber === 24) ?  bytes[i].slice(j, 1) : sStoreURL[24+j];
////			sStoreURL[32+j] = (bitNumber === 32) ?  bytes[i].slice(j, 1) : sStoreURL[32+j];
////			sStoreURL[40+j] = (bitNumber === 40) ?  bytes[i].slice(j, 1) : sStoreURL[40+j];
////			sStoreURL[48+j] = (bitNumber === 48) ?  bytes[i].slice(j, 1) : sStoreURL[48+j];
////			sStoreURL[56+j] = (bitNumber === 56) ?  bytes[i].slice(j, 1) : sStoreURL[56+j];
////
////		}
//
////			SWITCH(bitNumber)
////			{
////				CASE(0) {
////					sStoreURL.next[0+j] <== bytes[i].slice(j, 1);
////				}
////
////				CASE(8) {
////					sStoreURL.next[8+j] <== bytes[i].slice(j, 1);
////				}
////
////				CASE(16) {
////					sStoreURL.next[16+j] <== bytes[i].slice(j, 1);
////				}
////
////				CASE(24) {
////					sStoreURL.next[24+j] <== bytes[i].slice(j, 1);
////				}
////
////				CASE(32) {
////					sStoreURL.next[32+j] <== bytes[i].slice(j, 1);
////				}
////
////				CASE(40) {
////					sStoreURL.next[40+j] <== bytes[i].slice(j, 1);
////				}
////
////				CASE(48) {
////					sStoreURL.next[48+j] <== bytes[i].slice(j, 1);
////				}
////
////				CASE(56) {
////					sStoreURL.next[56+j] <== bytes[i].slice(j, 1);
////				}
////			}
////		}
//
//		return sStoreURL;
//
//	}
//
//	void do_nothing()
//	{
//
//	}

}
