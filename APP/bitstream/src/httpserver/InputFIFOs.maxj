package httpserver;


import java.util.ArrayList;

import com.maxeler.maxcompiler.v2.managers.DFEManager;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPullOutput;
import com.maxeler.maxcompiler.v2.statemachine.manager.DFEsmPushInput;
import com.maxeler.maxcompiler.v2.statemachine.manager.ManagerStateMachine;
import com.maxeler.maxcompiler.v2.statemachine.stdlib.Buffer.BufferSpec;
import com.maxeler.maxcompiler.v2.statemachine.stdlib.Buffer.DFEsmFifoConfig;
import com.maxeler.maxcompiler.v2.statemachine.stdlib.buffer.DFEsmFifo;
import com.maxeler.maxcompiler.v2.statemachine.types.DFEsmValueType;
import com.maxeler.networking.v1.managers.netlib.TCPStreamManyConnections;

public class InputFIFOs extends ManagerStateMachine {

	private final ArrayList<DFEsmPushInput> inputPorts = new ArrayList<DFEsmPushInput>(HttpServerManager.getNsockets());
	private final ArrayList<DFEsmPullOutput> outputPorts = new ArrayList<DFEsmPullOutput>(HttpServerManager.getNsockets());

	//private final DFEsmPushInput m_input;
	//private final DFEsmPullOutput m_output;
	private final DFEsmFifo[] m_fifo = new DFEsmFifo[HttpServerManager.getNsockets()];
	//private final DFEsmStateValue m_almostEmptyCounter;

	private final int width;

	public final int getWidth() {
		return width;
	}

	public InputFIFOs(DFEManager owner, TCPStreamManyConnections tcpStream) {
		super(owner);
		width=tcpStream.getTypes().getRxDataRespType().getTotalBits();

		for(int i=0;i<HttpServerManager.getNsockets();i++)
		{
			String inputName = "socketNumberInput" + String.valueOf(i);
			inputPorts.add(io.pushInput(inputName, dfeUInt(width), 1));

			String outputName = "socketNumberOutput" + String.valueOf(i);
			outputPorts.add(io.pullOutput(outputName, dfeUInt(width), 1));
		}

		final DFEsmValueType type = dfeUInt(width);

		//m_input = io.pushInput("input", type, inLatency);
		//m_output = io.pullOutput("output", type, outLatency);

		// computer says FIFO depth must be a power of two
		// we add one to the number to have a minimum slack of 2
		// items before stalling input
		// It also says depths of less than 8 are bad... I found
		// Xilinx's doc for FIFOs and it says min depth is 16
		// http://www.xilinx.com/support/documentation/ip_documentation/fifo_generator_ug175.pdf
		final int fifoDepth = 256; //Math.max(16, 1 <<	(MathUtils.bitsToAddress(Math.max(inLatency, outLatency)+2)));

		final int progEmptyLatency = 5; //Math.max(outLatency, 7);
		//m_almostEmptyStartCount = progEmptyLatency - outLatency;

		final DFEsmFifoConfig fifoConfig = new DFEsmFifoConfig()
				.setBufferSpec(BufferSpec.UseLUTRam)
				.setProgrammableFull(fifoDepth)
				.setProgrammableEmpty(progEmptyLatency)
				.setHasValidFlag()
				.setHasDataCount();


		for(int i=0;i<HttpServerManager.getNsockets();i++)
		{
			m_fifo[i] = buffer.fifo(type, fifoDepth, fifoConfig);
		}



//		if (m_almostEmptyStartCount > 0) {
//			m_almostEmptyCounter = state.value(dfeUInt(
//					MathUtils.bitsToRepresentUnsigned(m_almostEmptyStartCount)), 0);
//		} else {
//			m_almostEmptyCounter = null;
//		}

	}



	@Override
	protected void nextState() {
//		m_fifo.input.writeEnable <== m_input.valid;
//		m_fifo.input.dataIn <== m_input;
//		m_fifo.output.readEnable <== m_output.read;
//		if (null != m_almostEmptyCounter) {
//			IF (m_fifo.output.progEmpty) {
//				IF (m_output.read & ~m_input.valid & m_almostEmptyCounter.gt(0)) {
//					m_almostEmptyCounter.next <== m_almostEmptyCounter - 1;
//				}
//			} ELSE {
//				m_almostEmptyCounter.next <== m_almostEmptyStartCount;
//			}
//		}

		for(int i=0;i<HttpServerManager.getNsockets();i++)
		{
			// input
			m_fifo[i].input.writeEnable <== inputPorts.get(i).valid;
			m_fifo[i].input.dataIn <== inputPorts.get(i);

			// output
			m_fifo[i].output.readEnable <== outputPorts.get(i).read;
			IF(inputPorts.get(i).valid)
			{
				debug.simPrintf("inputFIFOs: m_fifo[%i].input.dataIn=%x, m_fifo[%i].output.empty=%u\n",i, m_fifo[i].input.dataIn, i, m_fifo[i].output.empty);
			}
		}
	}

	@Override
	protected void outputFunction() {

		for(int i=0;i<HttpServerManager.getNsockets();i++)
		{
			//outputPorts.get(i) <== 0;
			//outputPorts.get(i). <== false;
			inputPorts.get(i).stall <== m_fifo[i].input.progFull;

			outputPorts.get(i).empty <== m_fifo[i].output.empty;
			outputPorts.get(i) <== m_fifo[i].output.dataOut;
		}

		//outputPorts.get(0).empty <== m_fifo.output.empty;



//		m_input.stall <== m_fifo.input.progFull;
//		m_output.empty <== m_fifo.output.empty;
//		if (null != m_almostEmptyCounter) {
//			m_output.almostEmpty <== m_almostEmptyCounter.eq(0);
//		} else {
//			m_output.almostEmpty <== m_fifo.output.progEmpty;
//		}
//		m_output <== m_fifo.output.dataOut;
//

	}

}
