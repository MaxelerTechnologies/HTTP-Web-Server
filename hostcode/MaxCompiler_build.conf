















#
# This file contains company wide default options for all MaxDC builds from
# all maxeda branches. These can be overridden on a per user or per project
# basis as required.
#
#
#
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# DO NOT MAKE CHANGES TO THIS FILE
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#
#
# Unless:
# * You are adding a new option OR
# * Have achieved consensus with all users who will be affected by the change.
#




















































release_mode = false

#
# Clustering (MaxQ) options
#

use_cluster = true
cluster_manager = primary-maxq-manager
cluster_manager_port = 7001
build.sub_process_timeout_hours = 48

# Set the priority of all jobs sent to the cluster by MaxDC
cluster.priority = 5


#
# Build directory options
#
# Builds are placed in a directory made up of three components:
# <root_dir> <datestamp> <user-specified>
# The <root> and <datestamp> components are specified in this file
# The user specified portion is given when a BuildManager is constructed
#

build.root_dir = /network-scratch/${USER}/maxdc_builds

#
# Control whether builds are put into datestamped directories. The format
# string is a parameter to the Java SimpleDateFormat class (so look in the
# Javadoc for details)
#
build.datestamp_builds = true
build.datestamp_builds_format = dd-MM-yy

build.print_run_job_hashes = false
build.arbitrated_core_cache = /network-infrastructure/maxcompiler_core_cache/

build.verbose_output = false
build.enable_source_backup = true
build.enable_source_svn_info = true

build.intercept_build_failed_exceptions = true

build.vhdl.show_entity_instance_origin = false


photon.generate_graphs = false        # ****This doesn't appear to be read anywhere in trunk    -- Stan 16/08/2010
photon.run_dot_dumper_pro = false
photon.coloured_graph_lines = true
photon.draw_control_nodes = true
photon.verbose_simulation = true

# Turning this on can cause dot to crash
photon.draw_groups = false

wrapper.generate_graphs = true


#
# Chip scope inserter command (default is inserter.sh which is wrong)
# Also added 4096MB memory limit, necessary for large designs - RD
#
inserter.command = _JAVA_OPTIONS="-Xmx4096m" inserter

#
# MaxCompilerSim options
#

# simulation.compile.cc is ignored as of 2010.4 (FigRoll)
simulation.compile.cc = gcc
# simulation.compile.cflags is ignored as of 2010.4 (FigRoll)
simulation.compile.cflags = -Os
# simulation.compile.cxx is ignored as of 2010.4 (FigRoll)
simulation.compile.cxx = g++
# simulation.compile.cxxflags is ignored as of 2010.4 (FigRoll)
simulation.compile.cxxflags = $(CFLAGS)



simulation.compile.generate_debug_info = 0
# default: 0
# values: 0 .. 3 (0 = off, > 0 = on)


simulation.compile.explicit_template_instantiation = 1
# default: 1
# values: 0 .. 1 (0 = off, 1 = on)


simulation.compile.precompiled_header = 1
# default: 1
# values: 0 .. 1 (0 = off, 1 = precompiled headers)


simulation.compile.max_optimization_level = 2
# default: 2
# values: 0 .. 3


simulation.compile.parallelism = 2

#
# Execution options for external tools
#

# Can change to 'isim'
build.hdl_simulator = modelsim

build.ise_version = 13.3

coregen.command = DISPLAY=$DUMMY_XSERVER xilic coregen
coregen.gtp_aurora.command = source /network-raid/opt/ise-10.1/ISE/settings64.sh ; DISPLAY=$DUMMY_XSERVER coregen

xst.command = ulimit -s unlimited && xilic retry xst
#xst.command = ulimit -s unlimited && /network-raid/opt/memusescripts/memmonitor xilic retry xst
xst.ram_usage = 6144
xst.cluster_tags = linux;longrun

ngc2edif.command = xilic ngc2edif
ngc2edif.ram_usage = 1024
ngc2edif.cluster_tags = linux

partgen.command = xilic partgen

ngcbuild.command = xilic ngcbuild
ngcbuild.ram_usage = 4096
ngcbuild.cluster_tags = linux

ngdbuild.command = xilic ngdbuild
ngdbuild.ram_usage = 4096
ngdbuild.cluster_tags = linux

# NB Map/Par allocated just under 12GiB to allow 4 instances per 48GB compute node
mapper.command = xilic map
#mapper.command = /network-raid/opt/memusescripts/memmonitor xilic map
mapper.ram_usage = 12000
mapper.cluster_tags = linux;longrun

par.command = xilic par
#par.command = /network-raid/opt/memusescripts/memmonitor xilic par
par.ram_usage = 12000
par.cluster_tags = linux;longrun

xdl.command = xilic xdl
xdl.ram_usage = 4096
xdl.cluster_tags = linux

trce.command = xilic trce
trce.ram_usage = 8192
trce.cluster_tags = linux

modelsim.ram_usage = 1024
vsim.command = LM_LICENSE_FILE=1650@aries:1717@sliserver26:1717@horst vsim
vsim.retries = 5
vsim.retry_delay = 60
vsim.sim_license_view_only = true

bitgen.command = xilic bitgen
bitgen.ram_usage = 5120

# MaxFile runs bitgen and XDL
# Note this runs Bitgen which needs a license.  normally this doesn't matter as
# we have a bitgen script which runs xilic internally.
maxfile.command=${MAXCOMPILERDIR}/bin/maxfilestitch
maxfile.ram_usage = 5120
maxfile.cluster_tags = linux

dot.ram_usage = 2048

buildresource.abort_when_overmapped_bram = true
buildresource.abort_when_overmapped_dsps = true
buildresource.abort_when_overmapped_ffs = false
buildresource.autoresize = true
buildresource.small_build_is = 100000
buildresource.medium_build_is = 150000
buildresource.small_build_factor = 50
buildresource.medium_build_factor = 70

buildresource.medium_threshold=150000
buildresource.large_threshold=300000
buildresource.ram_map_small=2048
buildresource.ram_map_medium=8192
buildresource.ram_map_large=14336
buildresource.ram_par_small=2048
buildresource.ram_par_medium=6144
buildresource.ram_par_large=10240

# Updated to 13.1 on 2014-05-20
build.quartus_version = 13.1
build.quartus_command_prefix = source /network-raid/opt/quartus-13.1/quartus_path.sh;

megawiz.command = DISPLAY=$DUMMY_XSERVER qmegawiz --64bit

# cpu_usage is not just a declaration, but gets passed to quartus_map
#quartus_map.command = quartus_map
quartus_map.cpu_usage = 1
quartus_map.ram_usage = 26000
quartus_map.cluster_tags = linux;longrun

# cpu_usage is not just a declaration, but gets passed to quartus_fit
#quartus_fit.command = quartus_fit
quartus_fit.cpu_usage = 3
quartus_fit.ram_usage = 30000
quartus_fit.cluster_tags = linux;longrun

#quartus_asm.command = quartus_asm
quartus_asm.ram_usage = 12000
quartus_asm.cluster_tags = linux

# cpu_usage is not just a declaration, but gets passed to quartus_sta
#quartus_sta.command = quartus_sta
quartus_sta.cpu_usage = 2
quartus_sta.ram_usage = 16000
quartus_sta.cluster_tags = linux;longrun

#quartus_cdb.command = quartus_cdb
quartus_cdb.cpu_usage = 1
quartus_cdb.ram_usage = 6000
quartus_cdb.cluster_tags = linux

#quartus_cpf.command = quartus_cpf
quartus_cpf.cpu_usage = 1
quartus_cpf.ram_usage = 2048
quartus_cpf.cluster_tags = linux

