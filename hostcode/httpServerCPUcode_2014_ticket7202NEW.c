#define _GNU_SOURCE
#define CEILING_POS(X) ((X-(uint64_t)(X)) > 0 ? (uint64_t)(X+1) : (uint64_t)(X));

#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>

#include <MaxSLiCInterface.h>
#include "httpServer.h"
#include <math.h>

void generateInputData(int size, uint64_t *inData) {
	srand(time(0));
	for (int i = 0; i < size; i++) {
		inData[i] = i;
	}
}

typedef struct tx_event_type_s {
	uint16_t socketID :16;
	uint64_t frameCount;
	uint64_t reserved :48;
}__attribute__ ((__packed__)) tx_event_type_t;

void writeDataToLMem(uint64_t *dataIn, int size, int sizeBytes, int burstLengthInBytes, max_engine_t *engine, max_file_t *maxfile) {

		printf("size=%d, sizeBytes=%d, burstLengthInBytes=%d\n", size, sizeBytes, burstLengthInBytes);

		printf("Performing max_actions_init()\n");
	max_actions_t *actions = max_actions_init(maxfile, NULL);
		printf("Done\n");

	max_set_ticks(actions, "KernelLMem_Write_CommandAndDataStream", size);
	max_set_uint64t(actions, "KernelLMem_Write_CommandAndDataStream", "totalBursts", size * 8 / burstLengthInBytes);
	max_set_uint64t(actions, "KernelLMem_Write_CommandAndDataStream", "wordsPerBurst", burstLengthInBytes / 8);
	max_set_ticks(actions, "KernelLMem_Read_CommandAndDataStream", 0);
	max_set_uint64t(actions, "KernelLMem_Read_CommandAndDataStream", "totalBursts", size * 8 / burstLengthInBytes);
	max_set_uint64t(actions, "KernelLMem_Read_CommandAndDataStream", "wordsPerBurst", burstLengthInBytes / 8);
	max_run(engine, actions);

	max_reset_engine(engine);

	max_queue_input(actions, "fromCpu", dataIn, sizeBytes);
	max_lmem_set_interrupt_on(actions, "toLmem");
		printf("Performing max_run()\n");
	max_run(engine, actions);
		printf("Done\n");
	max_actions_free(actions);

}

void readDataFromLMem(uint64_t *dataOut, int size, int sizeBytes, int burstLengthInBytes, max_engine_t *engine, max_file_t *maxfile) {

	max_actions_t *actions = max_actions_init(maxfile, NULL);

	max_set_ticks(actions, "KernelLMem_Write_CommandAndDataStream", 0);
	max_set_uint64t(actions, "KernelLMem_Write_CommandAndDataStream", "totalBursts", size * 8 / burstLengthInBytes);
	max_set_uint64t(actions, "KernelLMem_Write_CommandAndDataStream", "wordsPerBurst", burstLengthInBytes / 8);
	max_set_ticks(actions, "KernelLMem_Read_CommandAndDataStream", size);
	max_set_uint64t(actions, "KernelLMem_Read_CommandAndDataStream", "totalBursts", size * 8 / burstLengthInBytes);
	max_set_uint64t(actions, "KernelLMem_Read_CommandAndDataStream", "wordsPerBurst", burstLengthInBytes / 8);
	max_run(engine, actions);

	max_reset_engine(engine);

	max_queue_output(actions, "toCpu", dataOut, sizeBytes);
	max_run(engine, actions);
	max_actions_free(actions);

}

void fillRomCrcIndex(FILE *fpCrc, uint64_t **pCrc, long Lcrc) {

	size_t resultCrc;
	char *tr;
	double diffCrc = ceil(Lcrc / 8.0) - Lcrc / 8.0; //padding with NULL character - integer multiple of bytes (1B=8 bits)

	if (diffCrc != 0) {
		Lcrc = (int) ceil(Lcrc / 8.0) * 8;
	}

	//allocate memory to contain the whole file
	size_t NelemCrc = sizeof(uint64_t) * (Lcrc / 8);
	uint64_t* nizCrc = (uint64_t*) malloc(NelemCrc);

	resultCrc = fread(nizCrc, 1, Lcrc, fpCrc); //read 8 bytes (64 bits) ie. 8 elements of 1 byte in size


	for (int i = 0; i < Lcrc / 8; i++) {
		tr = (char*) (nizCrc + i);
		//byte reverse
		for (int j = 0; j < 4; j++) {
			char wt = tr[j];
			tr[j] = tr[7 - j];
			tr[7 - j] = wt;
		}
	}

	*pCrc = nizCrc;

}

int main(int argc, char *argv[]) {
	if (argc != 3) {
		printf("Usage: %s <dfe_ip> <netmask>\n", argv[0]);
		return 1;
	}

	uint16_t Nsockets = 1;
	const int port = 80;
	struct in_addr dfe_ip;
	inet_aton(argv[1], &dfe_ip);
	struct in_addr netmask;
	inet_aton(argv[2], &netmask);

	// initialization files for crcIndex table, generated by init_code
	char fileCrcIndex1[] = "./results/romCrcIndex1_init.html";
	char fileCrcIndex2[] = "./results/romCrcIndex2_init.html";

	// LMEM initialization file location, generated by init_code
	char fileLmem[] = "./results/lmem_generated_file.html";

	uint64_t *arrCrc1;
	uint64_t *arrCrc2;
	long Lcrc;

	FILE *fpCrc1 = fopen(fileCrcIndex1, "rb");
	FILE *fpCrc2 = fopen(fileCrcIndex2, "rb");
	FILE *fpLmem = fopen(fileLmem, "rb");

	if (!(fpCrc1 && fpCrc2 && fpLmem)) {
		printf("Error with file\n");
		exit(0);
	}

	// obtain file size
	fseek(fpCrc1, 0, SEEK_END);
	Lcrc = ftell(fpCrc1);
	rewind(fpCrc1);

	fillRomCrcIndex(fpCrc1, &arrCrc1, Lcrc);
	fillRomCrcIndex(fpCrc2, &arrCrc2, Lcrc);

	printf("Preparing for init() and max_load()\n");
	max_file_t *maxfile = httpServer_2014_ticket7202NEW_init();
	max_engine_t * engine = max_load(maxfile, "*");
	printf("Done\n");

	max_actions_t *actions = max_actions_init(maxfile, NULL);

	int romDepthCrc = Lcrc / 8;
	for (uint32_t i = 0; i < romDepthCrc; i++) {
		max_set_mem_uint64t(actions, "CrcIndexTable", "romCrcIndex1", i, arrCrc1[i]);
		max_set_mem_uint64t(actions, "CrcIndexTable", "romCrcIndex2", i, arrCrc2[i]);
	}

	max_run(engine, actions);
	max_actions_free(actions);

	long L;
	size_t result;
	uint64_t* arrLmem;

	// obtain file size
	fseek(fpLmem, 0, SEEK_END);
	L = ftell(fpLmem);
	rewind(fpLmem);

	double diff = ceil(L / 8.0) - L / 8.0; // NULL character padding

	if (diff != 0) {
		L = (int) ceil(L / 8.0) * 8;
	}

	// allocate memory to contain the whole file
	size_t Nelem = sizeof(uint64_t) * (L / 8);
	arrLmem = (uint64_t*) malloc(Nelem);

	result = fread(arrLmem, 1, L, fpLmem); //read 8 bytes (64 bits) ie. 8 elements of 1 byte in size

	int romDepth = L / 8;

	int burstLengthInBytes = max_get_burst_size(maxfile, "cmd_tolmem");
	inline int max(int a, int b) {
		return a > b ? a : b;
	}
	;

	const int size = romDepth;
	int sizeBytes = size * sizeof(uint64_t);
	uint64_t *inData; // = malloc(sizeBytes);

	//generateInputData(size, inData);

	//action #1


	printf("Writing to DFE memory.\n");
	inData = arrLmem;

//	for (int i = 0; i < size; i++) {
//				printf("Initialize LMEM: element %d, inData[%d]=%016llx\n",i,i, (long long unsigned int) inData[i]);
//	}

	writeDataToLMem(inData, size, sizeBytes, burstLengthInBytes, engine, maxfile);
	//writeDataToLMem(inData, 0, sizeBytes, burstLengthInBytes, engine, maxfile);
	printf("Done\n");

	//action #2

//	  printf("Reading DFE memory.\n");
//		uint64_t *outData = malloc(sizeBytes);
//		readDataFromLMem(outData, size, sizeBytes, burstLengthInBytes, engine, maxfile);
//		for (int i = 0; i < size; i++) {
//			//printf("Reading LMEM: element %d, outData[%d]=%016llx\n",i,i,(long long unsigned int) outData[i]);
//			char* tt;
//			tt = (char *) &outData[i];
//			char ttnew[9];
//			for(int k=0;k<8; k++)
//			{
//				ttnew[k]=(*tt);
//				tt++;
//			}
//			ttnew[8]='\0';
//
//			printf("Reading LMEM: element %d, ASCII outData[%d]=%s, outData[%d]=%016llx\n", i, i, ttnew, i, (long long unsigned int) outData[i]);
//		}

	//exit(1);

	max_ip_config(engine, MAX_NET_CONNECTION_QSFP_BOT_10G_PORT1, &dfe_ip, &netmask);

	//all sockets MUST be created before first call to max_tcp_connect or max_tcp_listen
	max_tcp_socket_t *(dfe_socket[Nsockets]);
	uint16_t socketNumber[Nsockets];

	for (int i = 0; i < Nsockets; i++) {
		//dfe_socket[i] = max_tcp_create_socket(engine, "tcp_ISCA_QSFP_BOT_10G_PORT1");
		dfe_socket[i] = max_tcp_create_socket_with_number(engine, "tcp_ISCA_QSFP_BOT_10G_PORT1", i);
		socketNumber[i] = max_tcp_get_socket_number(dfe_socket[i]);
		printf("Socket %d was assigned socket number %u\n", i, socketNumber[i]);
	}

	for (int i = 0; i < Nsockets; i++) {
		max_tcp_listen(dfe_socket[i], port + i);
		max_tcp_await_state(dfe_socket[i], MAX_TCP_STATE_LISTEN, NULL);
	}

	printf("CPU code: Total %u socket(s), listening on the port(s) %u-%u\n\n", Nsockets, port, port + Nsockets - 1);

	//	uint64_t frameCounter = 0;
	//	uint64_t frameCounterPrevious = 0;

	void *read_ptr;
	uint8_t *read_buffer;
	max_llstream_t *read_llstream;
	uint64_t *byteNumber;
	printf("CPU code: Setting up 'toCpuByteNumber' stream.\n");
	int Nslots_byteNumber = 512;
	size_t tCBN_buffer_size = Nslots_byteNumber * 16;
	posix_memalign((void *) &read_buffer, 4096, tCBN_buffer_size);
	read_llstream = max_llstream_setup(engine, "toCpuFileSizeBytes", Nslots_byteNumber, 16, read_buffer);

	//	int Nslots_OutputTxEvent = 1;
	//	size_t txMgr_buffer_size = Nslots_OutputTxEvent * sizeof(tx_event_type_t);
	//	void *txMgr_buffer;
	//	posix_memalign(&txMgr_buffer, 4096, txMgr_buffer_size);
	//	max_llstream_t *llstream = max_llstream_setup(engine, "toCpuOutputTxEvent", Nslots_OutputTxEvent, sizeof(tx_event_type_t), txMgr_buffer);
	//	void *txMgrSlot;
	//	tx_event_type_t *event;


	uint8_t *read_buffer_socket;
	max_llstream_t *read_llstream_socket;
	printf("CPU code: Setting up 'toCpuSocketNumber' stream.\n");
	int Nslots_socketNumber = 512;
	size_t tCSB_buffer_size = Nslots_socketNumber * 16;
	posix_memalign((void *) &read_buffer_socket, 4096, tCSB_buffer_size);
	read_llstream_socket = max_llstream_setup(engine, "toCpuSocketNumber", Nslots_socketNumber, 16, read_buffer_socket);
	void *read_ptr_socket_slot;

//	uint64_t num_rx_bytes;
//	uint64_t num_tx_bytes;
//	uint8_t session_id;
//	int ti = 0;
//	while (1) {
//		for (int i = 0; i < Nsockets; i++) {
//			max_tcp_get_num_bytes_received(dfe_socket[i], &num_rx_bytes);
//			max_tcp_get_num_bytes_transmitted(dfe_socket[i], &num_tx_bytes, &session_id);
//			printf("CPU code: time=%i, port=%u, socket=%i, max_tcp_get_num_bytes_received=%llu, max_tcp_get_num_bytes_transmitted=%llu\n", ti, port + i, i, (long long unsigned int) num_rx_bytes, (long long unsigned int) num_tx_bytes);
//		}
//		ti++;
//		printf("\n");
//		usleep(1000 * 1000);
//	}

	//	uint8_t session_id;
	//	uint64_t num_tx_bytes;
	//	while (1) {
	//		max_tcp_get_num_bytes_transmitted(dfe_socket[0], &num_tx_bytes, &session_id);
	//		printf("CPU code: socket=%i, num_tx_bytes(max_tcp_get_num_bytes_transmitted)=%llu\n", 0,(long long unsigned int) num_tx_bytes);
	//		usleep(1000 * 1000);
	//	}

	uint16_t ti=10;
	while(ti>0)
	{
		printf("CPU code: time=%u, waiting file size and socket numbers stream data to be sent to CPU\n", ti);
		usleep(1000*1000*1);
		ti--;
	}

	//while(1);


	uint64_t num_rx_bytes;
	uint64_t num_tx_bytes;
	uint8_t session_id;
	while (1) {

		//part 1: first wait to receive LengthBytes number

		printf("CPU code: PART 1 - waiting to receive LengthBytes number\n");

		int FoundByteNumber = 0;
		ti=0;
		while (FoundByteNumber != 1) //first wait to receive LengthBytes number
		{
			usleep(1000*1000*1);

			for (int i = 0; i < Nsockets; i++) {
				max_tcp_get_num_bytes_received(dfe_socket[i], &num_rx_bytes);
				max_tcp_get_num_bytes_transmitted(dfe_socket[i], &num_tx_bytes, &session_id);
				printf("CPU code: waiting, time=%u, port=%u, socket=%i, max_tcp_get_num_bytes_received=%llu, max_tcp_get_num_bytes_transmitted=%llu\n", ti, port + i, i, (long long unsigned int) num_rx_bytes, (long long unsigned int) num_tx_bytes);
			}
			ti++;

			uint8_t ii = max_llstream_read(read_llstream, 1, &read_ptr);
			if (ii) {
				byteNumber = (uint64_t*) read_ptr;
				printf("CPU code: number of slots found to contain new data=%u,  fileSizeBytes=%u\n", ii, (unsigned int) *byteNumber);
				max_llstream_read_discard(read_llstream, 1);
				FoundByteNumber = 1;
			}
		}

		//part 2: receive total number of data transfered

		printf("CPU code: PART 2 - receive socket number\n");
		while (max_llstream_read(read_llstream_socket, 1, &read_ptr_socket_slot) == 0)
			;

		//event = txMgrSlot;
		//printf("CPU code: Got ack from TxManager: Total frames: %ld, socketID=%u\n", event->frameCount, event->socketID);
		//max_llstream_read_discard(llstream, 1);


		//frameCounter = (event->frameCount) + 1;
		//printf("CPU code: frameCounter=%ld\n", frameCounter);

		uint16_t socket_returned = (uint16_t) *((uint16_t*) read_ptr_socket_slot); //event->socketID;
		unsigned int fileBytes = (unsigned int) *byteNumber;

		printf("CPU code: fileBytes=%u, socket_returned=%u\n", fileBytes, socket_returned);

		ti=0;
		while (1) {
			{
				for (int i = 0; i < Nsockets; i++)
				{
					max_tcp_get_num_bytes_received(dfe_socket[i], &num_rx_bytes);
					max_tcp_get_num_bytes_transmitted(dfe_socket[i], &num_tx_bytes, &session_id);
					printf("CPU code: time=%i, port=%u, socket=%i, max_tcp_get_num_bytes_received=%llu, max_tcp_get_num_bytes_transmitted=%llu\n", ti, port + i, i, (long long unsigned int) num_rx_bytes, (long long unsigned int) num_tx_bytes);
				}
				ti++;
				printf("\n");

				max_tcp_get_num_bytes_transmitted(dfe_socket[socket_returned], &num_tx_bytes, &session_id);
				printf("CPU code: fileSizeBytes=%u, socketReturned=%u, num_tx_bytes=%llu\n", fileBytes, socket_returned, (long long unsigned int) num_tx_bytes);

			}

			//usleep(1000*100);
			//printf("CPU code: While LOOP, socket_returned=%u, fileBytes=%u, num_tx_bytes(max_tcp_get_num_bytes_transmitted)=%llu\n", socket_returned, fileBytes, (long long unsigned int) num_tx_bytes);
			if (num_tx_bytes == fileBytes) {
				//usleep(1000*1000*3);
				printf("CPU code: MATCH num_tx_bytes==fileBytes, socket_returned=%u, fileBytes=%u, num_tx_bytes(max_tcp_get_num_bytes_transmitted)=%llu\n", socket_returned, fileBytes, (long long unsigned int) num_tx_bytes);
				printf("CPU code: Closing socket=%u\n", socket_returned);
				max_tcp_close(dfe_socket[socket_returned]);
					//max_tcp_close_mode_t close_mode=MAX_TCP_CLOSE_ABORT_RESET;
					//max_tcp_close_advanced(dfe_socket[socket_returned],close_mode);

				printf("CPU code: Waiting for MAX_TCP_STATE_CLOSED\n");
				max_tcp_await_state(dfe_socket[socket_returned], MAX_TCP_STATE_CLOSED, NULL);

				printf("CPU code: Set LISTEN state\n");
				max_tcp_listen(dfe_socket[socket_returned], port);

				printf("CPU code: Waiting for MAX_TCP_STATE_LISTEN\n");
				max_tcp_await_state(dfe_socket[socket_returned], MAX_TCP_STATE_LISTEN, NULL);

				printf("CPU code: Again opened socket=%u\n", socket_returned);

				printf("\nCPU code: State of rx/tx after socket closing\n");

				//usleep(1000*1000*5);

//				for (int i = 0; i < Nsockets; i++)
//				{
//					max_tcp_get_num_bytes_received(dfe_socket[i], &num_rx_bytes);
//					max_tcp_get_num_bytes_transmitted(dfe_socket[i], &num_tx_bytes, &session_id);
//					printf("CPU code: port=%u, socket=%i, max_tcp_get_num_bytes_received=%llu, max_tcp_get_num_bytes_transmitted=%llu\n", port + i, i, (long long unsigned int) num_rx_bytes, (long long unsigned int) num_tx_bytes);
//				}
//				printf("\n");

//				max_tcp_close(dfe_socket[socket_returned]);
//				printf("max_tcp_close(dfe_socket[%u])", socket_returned);
//				dfe_socket[socket_returned] = max_tcp_create_socket_with_number(engine, "tcp_ISCA_QSFP_BOT_10G_PORT1", socket_returned);
//				printf("Socket %d was REASSIGNED socket number\n", socket_returned);
//
//				printf("Waiting for MAX_TCP_STATE_LISTEN\n");
//				max_tcp_listen(dfe_socket[socket_returned], port + socket_returned);
//				max_tcp_await_state(dfe_socket[socket_returned], MAX_TCP_STATE_LISTEN, NULL);

				break;
			}

			usleep(1000*1000*1);
		}
	}

	for (int i = 0; i < Nsockets; i++) {
		max_tcp_close(dfe_socket[i]);
		printf("max_tcp_close(dfe_socket[i])");
	}

	max_unload(engine);
	printf("max_unload(engine)");
	max_file_free(maxfile);
	printf("max_file_free(maxfile)");

	printf("The end\n");

	return 0;

}
